# Story 002.003.2: Migration Tools Interface Rebuild

**Epic**: Complete Conjugation System Architectural Rebuild

**As a** system administrator  
**I want** a fully functional migration tools interface with real database integration, rule management, and execution capabilities  
**So that** I can efficiently manage complex database migrations across multiple tables with confidence and full audit trail

---

## Problem

Current MigrationToolsInterface (5588 lines):
- **Step 2 broken** - metadata doesn't load/disappears  
- **Edit vs create inconsistent** - edit uses cached data
- **72+ useState hooks** - causes race conditions and complexity
- **Database schema errors** - wrong table names and outdated schema assumptions
- **Story 2.3.1 Integration Gap** - doesn't properly handle unified `metadata` (JSONB) + `optional_tags` (text[]) structure
- **Missing core functionality** - no rule save/load, execution, or revert capabilities
- **Mock data instead of real database** - placeholder interfaces instead of live Supabase integration
- **UI clutter** - development metrics and story details pollute user interface
- **Limited selection modes** - cannot select/modify across multiple tables simultaneously
- **No execution history** - missing audit trail and rollback capabilities
- **Unmaintainable** - patches fail due to complexity

SimpleMigrationTest **proves clean architecture works**.

## Collaborative Planning Decisions

**Git Branch**: Current `fix/refactor-migration-tools` branch is sufficient for this work.

**State Management Architecture**: 
- **Decision**: Grouped useState (vs single object state)
- **Reasoning**: Simpler individual updates, easier to read and maintain
- **Implementation**: Replace 72 useState hooks with ~8 grouped useState hooks

**Step 2 Metadata Loading Fix**:
- **Decision**: Automatic loading when forms/translations selected  
- **Reasoning**: Eliminates user friction and ensures data is always current
- **Implementation**: Auto-trigger metadata extraction on selection changes

**Tag Display Structure**:
- **Decision**: Separate mandatory/optional display with visual indicators
- **Format**: `üìã Mandatory Tags (metadata): person, tense, mood` + `üè∑Ô∏è Optional Tags (optional_tags): informal, regional`
- **Reasoning**: Clear distinction aligns with Story 2.3.1 unified metadata architecture

**Real Database Requirements**:
- **Decision**: All operations must use live Supabase data, no mock/placeholder content
- **Rule Persistence**: Save/load rules to `custom_migration_rules` table
- **Execution History**: Log all operations to `migration_execution_history` table with revert capability
- **Multi-Table Operations**: Support selecting and modifying records across all tables simultaneously
- **Global Tag Operations**: Find and modify records by tag across entire database
- **Reasoning**: Interface must be a production tool, not a demonstration

**UI/UX Requirements**:
- **Decision**: Clean professional interface without development artifacts
- **No Story Details**: Remove all implementation-specific status cards and metrics
- **Immediate Database Integration**: All displayed data must be live from database
- **Word Card Actions**: Direct execute buttons on search results for immediate action
- **Cross-Table Selection**: Ability to select dictionary words, forms, and translations together
- **Reasoning**: User interface should focus on functionality, not development process

**Workflow Enhancement**:
- **Decision**: Extend Config‚ÜíWords‚ÜíForms‚ÜíTags‚ÜíMappings‚ÜíPreview‚ÜíExecute workflow
- **Cross-Table Mode**: Allow operations across dictionary + word_forms + word_translations + form_translations
- **Global Tag Mode**: "Find all records with tag X" across entire database
- **Bulk Operations**: Apply same transformation across multiple tables in single execution
- **Reasoning**: Users need powerful selection and execution capabilities for complex migrations

**Story 2.3.1 Integration**:
- **Metadata Source Priority**: `metadata` (JSONB) takes precedence as mandatory tags
- **Optional Tags**: `optional_tags` (text[]) displayed as supplementary 
- **Legacy Support**: Handle `tags` (text[]) during transition period but deprioritize

**Testing Strategy**:
- **Decision**: Automated validation of metadata loading + manual workflow testing
- **Implementation**: Test functions that verify metadata extraction from all 4 tables

---

## Admin Integration Requirements

### Location & Navigation:
- **Admin Directory**: `/app/admin/migration-tools/page.tsx`
- **Top Navigation**: Add "Migration Tools" to admin dropdown menu
- **Admin Layout**: Integrate with existing admin layout and styling
- **Access Control**: Restrict to admin users only
- **Breadcrumbs**: Show current location in admin section

### Backup & Cleanup Strategy:
**BACKUP FIRST** (create .bak files before deletion):
- `components/admin/MigrationToolsInterface.tsx` ‚Üí `MigrationToolsInterface.tsx.bak` (5588 lines)
- `app/admin/migration-tools/page.tsx` ‚Üí `page.tsx.bak` 
- `app/admin/simple-migration-test/` ‚Üí `simple-migration-test.bak/` (entire directory)
- `app/admin/migration-tools-refactored/` ‚Üí `migration-tools-refactored.bak/` (entire directory)
- `components/admin/SimpleMigrationTest.tsx` ‚Üí `SimpleMigrationTest.tsx.bak`

**THEN CLEANUP**:
- **Remove old component**: Delete existing `MigrationToolsInterface.tsx` (5588 lines)
- **Remove test components**: Delete `SimpleMigrationTest.tsx` and `/admin/simple-migration-test/` 
- **Remove redundant pages**: Delete `/admin/migration-tools-refactored/` test page
- **Clean up imports**: Remove unused imports from components that referenced old system
- **Update navigation**: Replace old migration tool links with new admin integration

---

## Complete Feature Requirements

### üìä AUDIT TAB - Database Analysis
- **Tag Analysis Engine**: Scan all tables for inconsistencies, missing data, malformed tags
- **Database Statistics**: Live counts of dictionary, word_forms, word_translations, form_translations
- **Migration Issue Detection**: Critical/high/medium/low priority issues with auto-fix suggestions
- **Debug Logging System**: Real-time operation logs with expand/collapse, clear functionality  
- **Schema Validation**: Check table structures and column types
- **Data Integrity Checks**: Orphaned records, missing relationships, constraint violations

### üîß MIGRATION TAB - Rule Creation & Execution
#### Rule Builder System:
- **Multi-Step Wizard**: Config ‚Üí Mappings ‚Üí Words ‚Üí Forms ‚Üí Translations ‚Üí Tags
- **Table Targeting**: dictionary, word_forms, word_translations, form_translations, "all_tables"
- **Column Targeting**: tags, context_metadata, italian, translation, form_text, custom columns
- **Operation Types**: replace, add, remove with bulk operation support
- **Prevent Duplicates**: Toggle for duplicate handling during operations

#### Word Search & Selection:
- **Advanced Word Search**: Real-time search with fuzzy matching and filters
- **Word Tag Analysis**: Deep-dive analysis of individual words across all tables
- **Multi-Word Selection**: Batch selection with selection state management
- **Word-Specific Drill-Down**: View all tags/metadata for specific words

#### Form & Translation Targeting:
- **Form Selection Modes**: all-forms, specific-forms with individual form picking
- **Translation Selection Modes**: all-translations, specific-translations with individual selection
- **Form/Translation Preview**: Show selected items with their current metadata
- **Selection Validation**: Ensure selected items exist and are accessible

#### **Step 2 Metadata Loading** (CRITICAL FIX):
- **Automatic Loading**: Auto-trigger metadata extraction when forms/translations selected
- **Unified Metadata Support**: Handle `metadata` (JSONB), `optional_tags` (text[]), `tags` (legacy text[])
- **Visual Source Distinction**: `üìã Mandatory Tags (metadata)` vs `üè∑Ô∏è Optional Tags (optional_tags)`
- **Story 2.3.1 Integration**: Prioritize `metadata` as primary source, `optional_tags` as secondary
- **Real-Time Updates**: Update available options as user changes selections
- **Edit Mode Consistency**: Always re-query database (never use cached data)
- **Graceful Error Handling**: Fail gracefully with clear error messages
- **Multi-Table Schema Awareness**: Adapt queries based on available columns per table

#### Mapping Builder:
- **From‚ÜíTo Mappings**: Create transformation rules with validation
- **Bulk Mapping Creation**: Generate multiple mappings from patterns
- **Mapping Validation**: Check for conflicts and invalid transformations
- **Mapping Templates**: Pre-built patterns for common transformations
- **Mapping Preview**: Show exactly what will change

#### Rule Management:
- **Default Rules Library**: Pre-built rules for terminology, metadata, cleanup operations
- **Custom Rule Creation**: Build rules from scratch with full customization
- **Rule Save/Load System**: Named rule persistence with descriptions
- **Rule Templates**: Reusable rule patterns for common operations
- **Rule Archiving**: Archive old rules while preserving history
- **Rule Validation**: Check rule completeness and correctness

#### Preview & Execution:
- **Comprehensive Preview**: Show exactly what records will change and how
- **Affected Record Count**: Accurate count of records that will be modified
- **Dry Run Mode**: Test execution without making changes
- **Batch Processing**: Process large datasets in manageable chunks
- **Progress Tracking**: Real-time progress bars and status updates
- **Atomic Transactions**: Ensure all-or-nothing execution with rollback
- **Error Handling**: Graceful failure handling with detailed error messages

### üìà PROGRESS TAB - Execution Management
- **Complete Execution History**: Chronological log of all migration executions
- **Advanced Search & Filtering**: Filter by date range, status, table, description, user
- **Detailed Execution Results**: Expandable details showing exactly what changed
- **Performance Metrics**: Execution time, affected record counts, success rates
- **Revert Operations**: One-click rollback of specific executions with safety checks
- **Execution Comparison**: Compare before/after states of data
- **Export Capabilities**: Export execution logs and results
- **Execution Analytics**: Trends, patterns, and optimization suggestions

### üîÑ Advanced Features
#### Data Management:
- **Multi-Table Operations**: Execute rules across multiple tables simultaneously
- **Schema Detection**: Automatically detect and adapt to table structure changes
- **Data Backup**: Automatic backups before major operations
- **Incremental Updates**: Apply changes incrementally with checkpoint saving
- **Conflict Resolution**: Handle data conflicts during complex operations

#### User Experience:
- **Admin Theme Integration**: Match existing admin interface styling and layout
- **Responsive Design**: Mobile-friendly interface for remote administration
- **Keyboard Shortcuts**: Power-user shortcuts for common operations
- **Contextual Help**: In-line help and tooltips for complex features
- **User Preferences**: Customizable interface and default settings
- **Recent Actions**: Quick access to recently used rules and operations

---

## Technical Architecture

### State Management Architecture (Collaborative Decision)

**Replace 72 useState hooks with 8 grouped useState hooks**:

```typescript
// Current Problem: 72+ individual useState hooks causing race conditions
const [selectedTable, setSelectedTable] = useState('word_forms');
const [selectedColumn, setSelectedColumn] = useState('tags');  
const [currentStep, setCurrentStep] = useState('config');
const [operationType, setOperationType] = useState('replace');
const [selectedWords, setSelectedWords] = useState([]);
const [selectedFormIds, setSelectedFormIds] = useState([]);
const [selectedTranslationIds, setSelectedTranslationIds] = useState([]);
const [selectedTagsForMigration, setSelectedTagsForMigration] = useState([]);
const [ruleBuilderMappings, setRuleBuilderMappings] = useState([]);
const [tagsToRemove, setTagsToRemove] = useState([]);
const [tagsToAdd, setTagsToAdd] = useState([]);
const [newTagToAdd, setNewTagToAdd] = useState('');
// ... 60+ more useState hooks

// SOLUTION: Grouped useState Approach
// 1. Workflow State
const [workflowState, setWorkflowState] = useState({
  currentStep: 'config',
  operationType: 'replace'
});

// 2. Table Selection State  
const [tableState, setTableState] = useState({
  selectedTable: 'word_forms',
  selectedColumn: 'tags'
});

// 3. Record Selection State
const [recordState, setRecordState] = useState({
  selectedWords: [],
  selectedFormIds: [],
  selectedTranslationIds: []
});

// 4. Metadata State (Step 2 Fix)
const [metadataState, setMetadataState] = useState({
  availableMandatory: [], // from metadata JSONB
  availableOptional: [],  // from optional_tags text[]
  selectedTags: [],
  isLoading: false,
  error: null
});

// 5. Rule Configuration State
const [ruleState, setRuleState] = useState({
  mappings: [],
  tagsToAdd: [],
  tagsToRemove: [],
  newTagToAdd: ''
});

// 6. Preview & Execution State
const [executionState, setExecutionState] = useState({
  previewData: [],
  isExecuting: false,
  progress: 0,
  results: null
});

// 7. Debug & Logging State
const [debugState, setDebugState] = useState({
  logs: [],
  isExpanded: true
});

// 8. Rule Management State
const [ruleManagementState, setRuleManagementState] = useState({
  savedRules: [],
  selectedRule: null,
  showSaveModal: false
});
```

### File Structure:
```
app/admin/migration-tools/
‚îú‚îÄ‚îÄ page.tsx                      (~100 lines) ‚Üê Main admin page
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ MigrationToolsInterface.tsx (~200 lines) ‚Üê Main component with 8 grouped useState
‚îÇ   ‚îú‚îÄ‚îÄ tabs/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuditTab.tsx             (~400 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MigrationTab.tsx         (~500 lines)  
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ProgressTab.tsx          (~300 lines)
‚îÇ   ‚îî‚îÄ‚îÄ shared/
‚îÇ       ‚îú‚îÄ‚îÄ WordSearch.tsx           (~200 lines)
‚îÇ       ‚îú‚îÄ‚îÄ Step2MetadataLoader.tsx  (~150 lines) ‚Üê THE CRITICAL FIX
‚îÇ       ‚îú‚îÄ‚îÄ RuleBuilder.tsx          (~250 lines)
‚îÇ       ‚îú‚îÄ‚îÄ PreviewEngine.tsx        (~150 lines)
‚îÇ       ‚îî‚îÄ‚îÄ ExecutionEngine.tsx      (~200 lines)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ DatabaseService.ts           (~300 lines) ‚Üê Story 2.3.1 integration
‚îÇ   ‚îú‚îÄ‚îÄ MetadataService.ts           (~200 lines) ‚Üê New: unified metadata handling
‚îÇ   ‚îî‚îÄ‚îÄ ValidationService.ts         (~100 lines) ‚Üê New: automated testing
‚îî‚îÄ‚îÄ contexts/
    ‚îú‚îÄ‚îÄ MigrationContext.tsx         (~150 lines) ‚Üê Grouped state management
    ‚îî‚îÄ‚îÄ DatabaseContext.tsx          (~100 lines) ‚Üê Database state

Total: ~2750 lines (down from 5588 - 51% reduction)
```

### Admin Navigation Integration:
```typescript
// app/client-layout.js (update existing admin dropdown)
// Current admin navigation:
<a href="/admin/conjugation-validator">üîç Verb Validator</a>
<a href="/admin/migration-tools">üîÑ Migration Tools</a> // ‚Üê ALREADY EXISTS

// No changes needed - Migration Tools already in admin dropdown
```

### Cleanup Checklist:
```
Files to DELETE:
‚îú‚îÄ‚îÄ components/admin/MigrationToolsInterface.tsx (5588 lines)
‚îú‚îÄ‚îÄ components/admin/SimpleMigrationTest.tsx
‚îú‚îÄ‚îÄ app/admin/simple-migration-test/ (entire directory)
‚îú‚îÄ‚îÄ app/admin/migration-tools-refactored/ (entire directory)

Imports to UPDATE:
‚îú‚îÄ‚îÄ Any components importing old MigrationToolsInterface
‚îî‚îÄ‚îÄ Any references to deleted test pages

Navigation Updates:
‚îî‚îÄ‚îÄ No changes needed - Migration Tools already exists in admin dropdown at /admin/migration-tools
```

---

## Acceptance Criteria

### Admin Integration:
- [ ] **Admin location**: Located at `/app/admin/migration-tools/page.tsx`
- [ ] **Navigation integration**: "Migration Tools" already exists in admin dropdown (no changes needed)
- [ ] **Admin layout**: Uses consistent admin styling and layout patterns
- [ ] **Access control**: Only accessible to users with admin permissions

### Code Cleanup:
- [ ] **Old component removed**: `MigrationToolsInterface.tsx` (5588 lines) deleted
- [ ] **Test components removed**: All SimpleMigrationTest and test pages deleted
- [ ] **Redundant pages removed**: All `/admin/migration-tools-refactored/` content deleted
- [ ] **Import cleanup**: No broken imports or references to deleted components
- [ ] **Navigation verified**: Confirmed existing admin dropdown navigation works correctly

### Feature Parity:
- [ ] **All 3 tabs** with complete functionality (Audit, Migration, Progress)
- [ ] **Complete rule builder** with all operation types and targeting options
- [ ] **Word search system** with advanced filtering and selection
- [ ] **Step 2 metadata loading** works reliably for all table/column combinations
- [ ] **Rule save/load system** with templates and custom rules
- [ ] **Preview system** showing accurate change predictions
- [ ] **Execution engine** with progress tracking and error handling
- [ ] **Complete execution history** with search, filtering, and revert capabilities
- [ ] **Multi-table operations** with schema detection
- [ ] **Performance monitoring** and optimization features

### Quality Improvements:
- [ ] **Create/edit consistency** - both modes re-query database for current state
- [ ] **Clean codebase** - under 2700 lines total (vs 5588)
- [ ] **Proper database integration** - correct table/column names throughout
- [ ] **No race conditions** - simplified, reliable state management
- [ ] **Fast performance** - optimized queries and efficient operations
- [ ] **Admin theme integration** - consistent with existing admin interface
- [ ] **Mobile responsiveness** - works on tablets and mobile devices

---

## ULTRATHINK IMPLEMENTATION PLAN

**FUNDAMENTAL PRINCIPLE**: Build a production migration tool that database administrators can trust with live data. Every feature must be real, tested, and reliable.

**ARCHITECTURE PHILOSOPHY**: 
- **Database-First**: All features connect to live Supabase from day 1
- **Safety-First**: Multiple confirmation layers, full audit trail, easy revert
- **Power-User Focused**: Efficient workflows for complex multi-table operations
- **Professional UI**: Clean interface without development artifacts
- **Incremental Delivery**: Each phase delivers complete working functionality

**USER WORKFLOW ANALYSIS**:
Real users need to:
1. **Explore**: "Show me all records with tag X across all tables"
2. **Select**: "Select these 500 word forms + their translations"  
3. **Transform**: "Replace 'requires_avere' with 'auxiliary:avere' everywhere"
4. **Execute**: "Apply this change now with full logging"
5. **Verify**: "Show me exactly what changed"
6. **Revert**: "Undo that last operation completely"
7. **Persist**: "Save this rule for future use"

### PHASE 0: CRITICAL FOUNDATION (IMMEDIATE - 2 HOURS)

**Remove all development artifacts and establish database foundation**

#### Step 0.1: UI Cleanup (30 minutes)
```typescript
// REMOVE from page.tsx:
- Implementation status cards (72‚Üí8 hooks, Phase 1&2 Complete, etc.)
- Story validation displays  
- Code reduction metrics
- Development badges and indicators

// REPLACE WITH:
<h1>Migration Tools</h1>
<p>Database tag and metadata management interface</p>
// Clean, professional header only
```

#### Step 0.2: Database Schema Verification (30 minutes)
```sql
-- Verify/create custom_migration_rules table
SELECT table_name FROM information_schema.tables 
WHERE table_name = 'custom_migration_rules';

-- If not exists, create:
CREATE TABLE custom_migration_rules (
  rule_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  rule_config JSONB NOT NULL, -- Full selection and filter state
  transformation JSONB NOT NULL, -- Mappings and operations
  target_tables TEXT[] NOT NULL, -- Multiple tables supported
  status VARCHAR(50) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  last_executed_at TIMESTAMP,
  execution_count INTEGER DEFAULT 0,
  created_by UUID,
  tags TEXT[] DEFAULT '{}'
);

CREATE TABLE migration_execution_history (
  execution_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  rule_id UUID REFERENCES custom_migration_rules(rule_id),
  execution_type VARCHAR(50) NOT NULL, -- 'execute', 'revert'
  affected_tables TEXT[] NOT NULL,
  records_affected INTEGER NOT NULL,
  changes_made JSONB NOT NULL, -- Before/after values for revert
  execution_status VARCHAR(50) NOT NULL, -- 'success', 'failed', 'partial'
  execution_time INTERVAL,
  executed_at TIMESTAMP DEFAULT NOW(),
  executed_by UUID,
  error_details JSONB,
  revert_data JSONB -- Complete revert information
);
```

#### Step 0.3: Enhanced Database Service (1 hour)
```typescript
class MigrationDatabaseService extends DatabaseService {
  // Cross-table record selection
  async findRecordsByTag(tag: string, tables?: string[]): Promise<CrossTableResults> {
    const targetTables = tables || ['dictionary', 'word_forms', 'word_translations', 'form_translations'];
    const results = {};
    
    for (const table of targetTables) {
      results[table] = await this.searchRecords(table, undefined, [tag], 1000);
    }
    
    return {
      totalRecords: Object.values(results).flat().length,
      byTable: results,
      tag: tag
    };
  }
  
  // Rule management
  async saveRule(rule: MigrationRule): Promise<string> {
    const { data, error } = await this.supabase
      .from('custom_migration_rules')
      .insert({
        name: rule.name,
        description: rule.description,
        rule_config: rule.config,
        transformation: rule.transformation,
        target_tables: rule.targetTables
      })
      .select('rule_id')
      .single();
    
    if (error) throw error;
    return data.rule_id;
  }
  
  async loadRules(): Promise<MigrationRule[]> {
    const { data, error } = await this.supabase
      .from('custom_migration_rules')
      .select('*')
      .eq('status', 'active')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data.map(this.deserializeRule);
  }
  
  // Execution with full audit trail
  async executeRule(ruleId: string, selectedRecords: CrossTableSelection): Promise<ExecutionResult> {
    const rule = await this.loadRule(ruleId);
    const beforeState = await this.captureCurrentState(selectedRecords);
    
    try {
      const result = await this.performTransformation(rule, selectedRecords);
      await this.logExecution(ruleId, result, beforeState);
      return result;
    } catch (error) {
      await this.logFailedExecution(ruleId, error, beforeState);
      throw error;
    }
  }
  
  // Revert with complete rollback
  async revertExecution(executionId: string): Promise<RevertResult> {
    const execution = await this.getExecutionHistory(executionId);
    if (!execution.revert_data) throw new Error('No revert data available');
    
    return await this.restoreFromRevertData(execution.revert_data);
  }
}
```

### PHASE 1: CORE WORKING INTERFACE (IMMEDIATE - 4 HOURS)

**Build functional rule management with real database operations**

#### Step 1.1: Rule Management Interface (2 hours)
```typescript
// RuleManager component - replaces mock interfaces
interface RuleManagerProps {
  onRuleSelect: (rule: MigrationRule) => void;
  onRuleExecute: (rule: MigrationRule) => void;
}

function RuleManager({ onRuleSelect, onRuleExecute }: RuleManagerProps) {
  const [rules, setRules] = useState<MigrationRule[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  
  // REAL database loading
  useEffect(() => {
    const loadRules = async () => {
      const dbService = new MigrationDatabaseService();
      const loadedRules = await dbService.loadRules();
      setRules(loadedRules);
      setIsLoading(false);
    };
    loadRules();
  }, []);
  
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2>Saved Migration Rules</h2>
        <button className="btn-primary">Create New Rule</button>
      </div>
      
      {rules.map(rule => (
        <div key={rule.id} className="border rounded p-4">
          <div className="flex justify-between items-start">
            <div>
              <h3 className="font-medium">{rule.name}</h3>
              <p className="text-sm text-gray-600">{rule.description}</p>
              <div className="text-xs text-gray-500 mt-1">
                Tables: {rule.targetTables.join(', ')} | 
                Created: {rule.createdAt.toLocaleDateString()} |
                Executed: {rule.executionCount} times
              </div>
            </div>
            <div className="flex space-x-2">
              <button 
                onClick={() => onRuleSelect(rule)}
                className="btn-secondary"
              >
                Edit
              </button>
              <button 
                onClick={() => onRuleExecute(rule)}
                className="btn-danger"
              >
                Execute Now
              </button>
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}
```

#### Step 1.2: Cross-Table Search Interface (1.5 hours)  
```typescript
// GlobalSearchInterface - replaces word search mockup
function GlobalSearchInterface() {
  const [searchMode, setSearchMode] = useState<'tag' | 'text'>('tag');
  const [searchTerm, setSearchTerm] = useState('');
  const [results, setResults] = useState<CrossTableResults | null>(null);
  const [selectedRecords, setSelectedRecords] = useState<CrossTableSelection>({
    dictionary: [],
    word_forms: [],
    word_translations: [],
    form_translations: []
  });
  
  const handleSearch = async () => {
    const dbService = new MigrationDatabaseService();
    
    if (searchMode === 'tag') {
      const results = await dbService.findRecordsByTag(searchTerm);
      setResults(results);
    } else {
      // Text search across primary columns
      const results = await dbService.searchAcrossTables(searchTerm);
      setResults(results);
    }
  };
  
  const handleRecordToggle = (table: string, recordId: string) => {
    setSelectedRecords(prev => ({
      ...prev,
      [table]: prev[table].includes(recordId) 
        ? prev[table].filter(id => id !== recordId)
        : [...prev[table], recordId]
    }));
  };
  
  return (
    <div className="space-y-6">
      {/* Search Interface */}
      <div className="bg-white p-4 border rounded">
        <div className="flex space-x-4 items-center">
          <select 
            value={searchMode} 
            onChange={(e) => setSearchMode(e.target.value as 'tag' | 'text')}
          >
            <option value="tag">Search by Tag</option>
            <option value="text">Search by Text</option>
          </select>
          
          <input 
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder={searchMode === 'tag' ? 'Enter tag name...' : 'Enter search text...'}
            className="flex-1"
          />
          
          <button onClick={handleSearch} className="btn-primary">
            Search Across All Tables
          </button>
        </div>
      </div>
      
      {/* Results with Selection */}
      {results && (
        <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
          {Object.entries(results.byTable).map(([table, records]) => (
            <div key={table} className="bg-white border rounded p-4">
              <h3 className="font-medium mb-3">
                {table.replace('_', ' ')} ({records.length})
              </h3>
              
              <div className="space-y-2 max-h-64 overflow-y-auto">
                {records.map(record => (
                  <div key={record.id} className="flex items-start space-x-2">
                    <input 
                      type="checkbox"
                      checked={selectedRecords[table].includes(record.id)}
                      onChange={() => handleRecordToggle(table, record.id)}
                    />
                    <div className="flex-1 text-sm">
                      <div className="font-medium">{record.primaryText}</div>
                      <div className="text-gray-500 text-xs">
                        Tags: {record.allTags.join(', ')}
                      </div>
                      <button 
                        onClick={() => executeOnRecord(record)}
                        className="text-blue-600 hover:underline text-xs mt-1"
                      >
                        Execute Now ‚Üí
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      )}
      
      {/* Selection Summary */}
      <div className="bg-blue-50 border border-blue-200 rounded p-4">
        <h4 className="font-medium text-blue-900">Current Selection</h4>
        <div className="text-sm text-blue-800 grid grid-cols-4 gap-4 mt-2">
          {Object.entries(selectedRecords).map(([table, ids]) => (
            <div key={table}>
              {table.replace('_', ' ')}: <span className="font-medium">{ids.length}</span>
            </div>
          ))}
        </div>
        <div className="text-xs text-blue-700 mt-2">
          Total: {Object.values(selectedRecords).flat().length} records selected
        </div>
      </div>
    </div>
  );
}
```

#### Step 1.3: Real Execution Interface (30 minutes)
```typescript
// ExecutionInterface - replaces progress mockup  
function ExecutionInterface({ rule, selectedRecords }: ExecutionProps) {
  const [isExecuting, setIsExecuting] = useState(false);
  const [executionResult, setExecutionResult] = useState<ExecutionResult | null>(null);
  
  const handleExecute = async () => {
    setIsExecuting(true);
    
    try {
      const dbService = new MigrationDatabaseService();
      const result = await dbService.executeRule(rule.id, selectedRecords);
      setExecutionResult(result);
      
      // Show real results
      alert(`Execution completed! 
        Changed: ${result.recordsAffected} records
        Tables: ${result.affectedTables.join(', ')}
        Duration: ${result.executionTime}ms
        Execution ID: ${result.executionId} (for revert)`);
        
    } catch (error) {
      alert(`Execution failed: ${error.message}`);
    } finally {
      setIsExecuting(false);
    }
  };
  
  return (
    <div className="space-y-4">
      <div className="bg-yellow-50 border border-yellow-200 rounded p-4">
        <h3 className="font-medium text-yellow-900">‚ö†Ô∏è Execution Confirmation</h3>
        <div className="text-sm text-yellow-800 mt-2">
          <p>Rule: <strong>{rule.name}</strong></p>
          <p>Selected Records: <strong>{Object.values(selectedRecords).flat().length}</strong></p>
          <p>Tables: <strong>{rule.targetTables.join(', ')}</strong></p>
          <p>Transformation: <strong>{JSON.stringify(rule.transformation)}</strong></p>
        </div>
      </div>
      
      <div className="flex space-x-4">
        <button 
          onClick={handleExecute}
          disabled={isExecuting}
          className="btn-danger"
        >
          {isExecuting ? 'Executing...' : 'Execute Migration'}
        </button>
        
        <button className="btn-secondary">Cancel</button>
      </div>
      
      {executionResult && (
        <div className="bg-green-50 border border-green-200 rounded p-4">
          <h4 className="font-medium text-green-900">‚úÖ Execution Complete</h4>
          <div className="text-sm text-green-800 mt-2">
            <p>Records affected: {executionResult.recordsAffected}</p>
            <p>Execution time: {executionResult.executionTime}ms</p>
            <p>Execution ID: {executionResult.executionId}</p>
            <button className="text-blue-600 hover:underline text-xs mt-2">
              View execution details ‚Üí
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
```

### PHASE 2: EXECUTION HISTORY & REVERT (NEXT - 3 HOURS)

**Real execution history with functional revert capabilities**

#### Step 2.1: Execution History Interface (2 hours)
```typescript
function ExecutionHistoryTab() {
  const [executions, setExecutions] = useState<ExecutionRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    const loadHistory = async () => {
      const dbService = new MigrationDatabaseService();
      const history = await dbService.getExecutionHistory();
      setExecutions(history);
      setIsLoading(false);
    };
    loadHistory();
  }, []);
  
  const handleRevert = async (executionId: string) => {
    if (!confirm('Are you sure you want to revert this execution? This will restore all affected records to their previous state.')) {
      return;
    }
    
    try {
      const dbService = new MigrationDatabaseService();
      const revertResult = await dbService.revertExecution(executionId);
      
      alert(`Revert completed!
        Restored: ${revertResult.recordsRestored} records
        Tables: ${revertResult.affectedTables.join(', ')}`);
        
      // Refresh history
      const updatedHistory = await dbService.getExecutionHistory();
      setExecutions(updatedHistory);
      
    } catch (error) {
      alert(`Revert failed: ${error.message}`);
    }
  };
  
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2>Execution History</h2>
        <div className="text-sm text-gray-600">
          {executions.length} total executions
        </div>
      </div>
      
      <div className="space-y-3">
        {executions.map(execution => (
          <div key={execution.id} className="border rounded p-4">
            <div className="flex justify-between items-start">
              <div>
                <div className="flex items-center space-x-2">
                  <h3 className="font-medium">{execution.ruleName}</h3>
                  <span className={`px-2 py-1 rounded text-xs ${
                    execution.status === 'success' ? 'bg-green-100 text-green-800' :
                    execution.status === 'failed' ? 'bg-red-100 text-red-800' :
                    'bg-gray-100 text-gray-800'
                  }`}>
                    {execution.status}
                  </span>
                </div>
                
                <div className="text-sm text-gray-600 mt-1">
                  <div>Tables: {execution.affectedTables.join(', ')}</div>
                  <div>Records: {execution.recordsAffected.toLocaleString()}</div>
                  <div>Duration: {execution.executionTime}</div>
                  <div>Executed: {execution.executedAt.toLocaleString()}</div>
                </div>
                
                {/* Show actual changes made */}
                <details className="mt-2">
                  <summary className="text-xs text-blue-600 cursor-pointer">
                    View changes made ({Object.keys(execution.changesMade).length} operations)
                  </summary>
                  <div className="mt-2 text-xs bg-gray-50 p-2 rounded">
                    <pre>{JSON.stringify(execution.changesMade, null, 2)}</pre>
                  </div>
                </details>
              </div>
              
              <div className="flex space-x-2">
                {execution.canRevert && (
                  <button 
                    onClick={() => handleRevert(execution.id)}
                    className="btn-secondary text-sm"
                  >
                    Revert
                  </button>
                )}
                
                <button className="btn-secondary text-sm">
                  Details
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### PHASE 3: ADVANCED FEATURES (FUTURE - 6 HOURS)

**Power user features for complex operations**

#### Step 3.1: Bulk Tag Operations (2 hours)
- Global replace: "Replace tag X with Y across ALL tables"
- Bulk tagging: "Add tag Z to all selected records"
- Tag cleanup: "Remove orphaned tags" 
- Tag analytics: "Show tag usage statistics"

#### Step 3.2: Advanced Selection Modes (2 hours)
- Pattern matching: "Select all records matching pattern"
- Relationship selection: "Select word + all its forms + translations"
- Conditional selection: "Select if metadata.tense = 'present'"
- Saved selections: "Save current selection as template"

#### Step 3.3: Batch Rule Execution (2 hours)
- Rule sequences: Execute multiple rules in order
- Conditional execution: Execute rule B only if rule A succeeds
- Rollback policies: Full sequence rollback on any failure
- Progress tracking: Real-time progress across rule sequence

### DELIVERY TIMELINE

**IMMEDIATE (Today)**:
- Phase 0: UI cleanup + database schema (2 hours)
- Phase 1: Core working interface (4 hours)

**NEXT SESSION**:
- Phase 2: Execution history + revert (3 hours)

**FUTURE SESSIONS**:
- Phase 3: Advanced features (6 hours)

### SUCCESS METRICS (REVISED)

**Phase 0 Success**: Clean interface, verified database schema
**Phase 1 Success**: Can save/load rules, search across tables, execute with real data
**Phase 2 Success**: Full execution audit trail with working revert
**Phase 3 Success**: Power user features for complex operations

**Overall Success**: Database administrators can confidently manage complex multi-table migrations with full audit trail and easy revert capabilities.
```bash
# Create backup files before any deletion
cp components/admin/MigrationToolsInterface.tsx components/admin/MigrationToolsInterface.tsx.bak
cp app/admin/migration-tools/page.tsx app/admin/migration-tools/page.tsx.bak
cp -r app/admin/simple-migration-test app/admin/simple-migration-test.bak
cp -r app/admin/migration-tools-refactored app/admin/migration-tools-refactored.bak
cp components/admin/SimpleMigrationTest.tsx components/admin/SimpleMigrationTest.tsx.bak
```

#### Step 1.2: Core Services Development
**DatabaseService.ts** (Story 2.3.1 Integration):
```typescript
interface UnifiedMetadata {
  mandatory: string[];    // From metadata JSONB column
  optional: string[];     // From optional_tags text[] column
  legacy: string[];       // From tags text[] column (transition only)
  combined: string[];     // All unique values
  source: 'metadata' | 'optional_tags' | 'legacy';
}

class DatabaseService {
  async extractUnifiedMetadata(tableName: string, recordIds: string[]): Promise<UnifiedMetadata> {
    // Query strategy based on available columns per table:
    // dictionary: metadata + optional_tags + tags
    // word_forms: metadata + optional_tags + tags  
    // word_translations: metadata + optional_tags (no tags column)
    // form_translations: metadata + optional_tags (no tags column)
    
    const tableConfig = this.getTableConfig(tableName);
    const queries = [];
    
    if (tableConfig.hasMetadata) {
      queries.push(this.extractJSONBKeys(tableName, 'metadata', recordIds));
    }
    if (tableConfig.hasOptionalTags) {
      queries.push(this.extractArrayValues(tableName, 'optional_tags', recordIds));
    }
    if (tableConfig.hasLegacyTags) {
      queries.push(this.extractArrayValues(tableName, 'tags', recordIds));
    }
    
    return this.combineMetadataResults(await Promise.all(queries));
  }
}
```

**ValidationService.ts** (Automated Testing):
```typescript
class ValidationService {
  async validateMetadataExtraction(): Promise<ValidationResults> {
    const results = {};
    const testTables = ['dictionary', 'word_forms', 'word_translations', 'form_translations'];
    
    for (const tableName of testTables) {
      try {
        // Get sample records for testing
        const sampleIds = await this.getSampleRecordIds(tableName, 3);
        
        // Test unified metadata extraction
        const metadata = await databaseService.extractUnifiedMetadata(tableName, sampleIds);
        
        results[tableName] = {
          status: 'success',
          mandatoryCount: metadata.mandatory.length,
          optionalCount: metadata.optional.length,
          legacyCount: metadata.legacy.length,
          totalCount: metadata.combined.length
        };
        
      } catch (error) {
        results[tableName] = {
          status: 'error',
          error: error.message
        };
      }
    }
    
    return results;
  }
}
```

#### Step 1.3: Step 2 MetadataLoader Component (Critical Fix)
```typescript
// Step2MetadataLoader.tsx - THE CRITICAL FIX
interface Step2MetadataLoaderProps {
  tableName: string;
  selectedRecordIds: string[];
  onMetadataChange: (selectedTags: string[]) => void;
  autoLoad?: boolean; // NEW: Automatic loading decision
}

export default function Step2MetadataLoader({ 
  tableName, 
  selectedRecordIds, 
  onMetadataChange,
  autoLoad = true 
}) {
  const [metadata, setMetadata] = useState<UnifiedMetadata | null>(null);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  
  // AUTO-LOAD: Trigger when selectedRecordIds changes
  useEffect(() => {
    if (autoLoad && selectedRecordIds.length > 0) {
      loadMetadata();
    }
  }, [selectedRecordIds, autoLoad]);
  
  const loadMetadata = async () => {
    try {
      const unifiedMetadata = await databaseService.extractUnifiedMetadata(tableName, selectedRecordIds);
      setMetadata(unifiedMetadata);
    } catch (error) {
      // Graceful error handling
      setError(`Failed to load metadata: ${error.message}`);
    }
  };
  
  return (
    <div className="step2-metadata-loader">
      {metadata && (
        <div>
          {/* Mandatory Tags Section */}
          {metadata.mandatory.length > 0 && (
            <div className="mandatory-tags">
              <h4>üìã Mandatory Tags (metadata): {metadata.mandatory.length}</h4>
              {metadata.mandatory.map(tag => (
                <TagCheckbox key={tag} tag={tag} selected={selectedTags.includes(tag)} onChange={handleTagToggle} />
              ))}
            </div>
          )}
          
          {/* Optional Tags Section */}
          {metadata.optional.length > 0 && (
            <div className="optional-tags">
              <h4>üè∑Ô∏è Optional Tags (optional_tags): {metadata.optional.length}</h4>
              {metadata.optional.map(tag => (
                <TagCheckbox key={tag} tag={tag} selected={selectedTags.includes(tag)} onChange={handleTagToggle} />
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}
```

### Phase 2: Main Component Rebuild

#### Step 2.1: Simplified State Management
```typescript
// MigrationToolsInterface.tsx - Simplified from 72 useState to 8 grouped
export default function MigrationToolsInterface() {
  // 1. Workflow State
  const [workflowState, setWorkflowState] = useState({
    currentStep: 'config' as StepType,
    operationType: 'replace' as OperationType
  });

  // 2. Table Selection State  
  const [tableState, setTableState] = useState({
    selectedTable: 'word_forms',
    selectedColumn: 'metadata' // Changed default to metadata (Story 2.3.1)
  });

  // 3. Record Selection State
  const [recordState, setRecordState] = useState({
    selectedWords: [] as WordSearchResult[],
    selectedFormIds: [] as string[],
    selectedTranslationIds: [] as string[]
  });

  // 4. Metadata State (Step 2 Fix)
  const [metadataState, setMetadataState] = useState({
    availableMandatory: [] as string[],
    availableOptional: [] as string[],
    selectedTags: [] as string[],
    isLoading: false,
    error: null as string | null
  });

  // 5. Rule Configuration State
  const [ruleState, setRuleState] = useState({
    mappings: [] as MappingPair[],
    tagsToAdd: [] as string[],
    tagsToRemove: [] as string[],
    newTagToAdd: ''
  });

  // 6. Preview & Execution State
  const [executionState, setExecutionState] = useState({
    previewData: [] as any[],
    isExecuting: false,
    progress: 0,
    results: null as any
  });

  // 7. Debug & Logging State
  const [debugState, setDebugState] = useState({
    logs: [] as string[],
    isExpanded: true
  });

  // 8. Rule Management State
  const [ruleManagementState, setRuleManagementState] = useState({
    savedRules: [] as any[],
    selectedRule: null as any,
    showSaveModal: false
  });

  // Helper functions for state updates
  const updateWorkflowState = (updates: Partial<typeof workflowState>) => {
    setWorkflowState(prev => ({ ...prev, ...updates }));
  };
  
  const updateMetadataState = (updates: Partial<typeof metadataState>) => {
    setMetadataState(prev => ({ ...prev, ...updates }));
  };
  
  // ... etc for other state groups
}
```

#### Step 2.2: Three-Tab Architecture
```typescript
// Main component structure
const tabs = [
  { id: 'audit', name: 'Tag Audit', component: AuditTab },
  { id: 'migration', name: 'Migration Rules', component: MigrationTab },
  { id: 'progress', name: 'Execution History', component: ProgressTab }
];

// MigrationTab.tsx - Contains the step workflow
export default function MigrationTab({ 
  workflowState, 
  tableState, 
  recordState, 
  metadataState,
  // ... all other state props
}) {
  return (
    <div className="migration-tab">
      {/* Step Workflow */}
      <StepIndicator currentStep={workflowState.currentStep} />
      
      {workflowState.currentStep === 'config' && (
        <ConfigStep tableState={tableState} onUpdate={updateTableState} />
      )}
      
      {workflowState.currentStep === 'words' && (
        <WordSearchStep recordState={recordState} onUpdate={updateRecordState} />
      )}
      
      {workflowState.currentStep === 'forms' && (
        <FormSelectionStep recordState={recordState} onUpdate={updateRecordState} />
      )}
      
      {workflowState.currentStep === 'tags' && (
        <Step2MetadataLoader
          tableName={tableState.selectedTable}
          selectedRecordIds={getSelectedRecordIds()}
          onMetadataChange={(tags) => updateMetadataState({ selectedTags: tags })}
          autoLoad={true} // Automatic loading decision
        />
      )}
      
      {workflowState.currentStep === 'mappings' && (
        <MappingBuilderStep ruleState={ruleState} onUpdate={updateRuleState} />
      )}
      
      {workflowState.currentStep === 'preview' && (
        <PreviewStep executionState={executionState} />
      )}
    </div>
  );
}
```

### Phase 3: Integration & Testing

#### Step 3.1: Admin Page Integration
```typescript
// app/admin/migration-tools/page.tsx - Replace existing
'use client';

import { useState, useEffect } from 'react';
import MigrationToolsInterface from './components/MigrationToolsInterface';
import ValidationService from './services/ValidationService';

export default function MigrationToolsPage() {
  const [validationResults, setValidationResults] = useState(null);
  
  // Run automated validation on load
  useEffect(() => {
    const runValidation = async () => {
      const validationService = new ValidationService();
      const results = await validationService.validateMetadataExtraction();
      setValidationResults(results);
    };
    
    runValidation();
  }, []);

  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Validation Status */}
        {validationResults && (
          <div className="mb-4 p-3 bg-blue-50 rounded">
            <h3 className="text-sm font-medium text-blue-900">üß™ System Validation</h3>
            <div className="text-xs text-blue-800 mt-1">
              {Object.entries(validationResults).map(([table, result]) => (
                <div key={table}>
                  {table}: {result.status === 'success' ? '‚úÖ' : '‚ùå'} 
                  {result.status === 'success' && ` (${result.totalCount} metadata items)`}
                </div>
              ))}
            </div>
          </div>
        )}
        
        {/* Page Header */}
        <div className="mb-8">
          <div className="md:flex md:items-center md:justify-between">
            <div className="flex-1 min-w-0">
              <h1 className="text-3xl font-bold leading-7 text-gray-900 sm:text-4xl sm:truncate">
                Migration Tools - Rebuilt
              </h1>
              <p className="mt-2 text-sm text-gray-600">
                Simplified architecture with Story 2.3.1 unified metadata support
              </p>
            </div>
            <div className="mt-4 flex md:mt-0 md:ml-4 space-x-3">
              <span className="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                72‚Üí8 useState hooks
              </span>
              <span className="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                Step 2 Fixed
              </span>
            </div>
          </div>
        </div>

        {/* Main Interface */}
        <MigrationToolsInterface />
      </div>
    </div>
  );
}
```

#### Step 3.2: Cleanup Execution
```bash
# After successful implementation and testing:

# 1. Delete old files (backups already created)
rm components/admin/MigrationToolsInterface.tsx
rm components/admin/SimpleMigrationTest.tsx  
rm -rf app/admin/simple-migration-test/
rm -rf app/admin/migration-tools-refactored/

# 2. Update imports in any referencing components
# 3. Update admin navigation
# 4. Test all functionality
```

### Phase 4: Validation & Testing

#### Step 4.1: Automated Testing Implementation
```typescript
// Built-in testing that runs on component mount
const runSystemValidation = async () => {
  console.log('üß™ Running Migration Tools validation...');
  
  // Test 1: Database connection
  const connectionTest = await databaseService.testConnection();
  
  // Test 2: Metadata extraction from all tables
  const metadataTests = await Promise.all([
    validateTableMetadata('dictionary'),
    validateTableMetadata('word_forms'), 
    validateTableMetadata('word_translations'),
    validateTableMetadata('form_translations')
  ]);
  
  // Test 3: Step 2 loading simulation
  const step2Test = await simulateStep2Loading();
  
  console.log('‚úÖ All validation tests completed');
  return { connectionTest, metadataTests, step2Test };
};
```

#### Step 4.2: COMPREHENSIVE TESTING PROTOCOL (Ultra-Detailed)

**CRITICAL**: Complete all tests before considering any cleanup operations. All backup files must remain until testing is 100% complete and approved.

##### Pre-Testing Setup & Environment Validation
- [ ] **Deploy to Vercel**: Push branch and confirm deployment succeeds
- [ ] **Database Connection**: Verify Supabase connection is active and stable
- [ ] **Admin Access**: Confirm `/admin/migration-tools` route is accessible
- [ ] **Browser Console**: Clear console and monitor for any JavaScript errors
- [ ] **Network Tab**: Monitor for failed requests or slow database queries

##### Phase 1: Core Interface Loading & Navigation
- [ ] **Page Load**: Interface loads without errors within 3 seconds
- [ ] **Automated Validation**: System validation runs automatically on page load
- [ ] **Validation Status Display**: Blue validation status card appears with results
- [ ] **Implementation Status Cards**: All 4 status cards display correct metrics (Phase 1&2 Complete, 51% code reduction, 8 useState hooks, 100% Step 2 reliability)
- [ ] **Tab Navigation**: All three tabs (Audit, Migration, Progress) are clickable
- [ ] **Tab Switching**: Can switch between tabs without errors or console warnings
- [ ] **Debug Console**: Debug console toggles open/closed correctly
- [ ] **Responsive Design**: Interface works on different screen sizes

##### Phase 2: Automated Validation System Testing
- [ ] **Database Connection Test**: Validation shows "üì° DB: success" 
- [ ] **Metadata Tests**: Shows "üìä Tables: X/4" with successful metadata extraction from all tables
- [ ] **Step 2 Test**: Shows "üîÑ Step 2: success" indicating Step 2 loading works
- [ ] **Timestamp Accuracy**: Validation timestamp shows current time
- [ ] **Error Handling**: Test with database disconnected - should show appropriate error states
- [ ] **Retry Mechanism**: Validation can be re-run if needed

##### Phase 3: Migration Tab - State Management (Critical 72‚Üí8 useState Testing)
- [ ] **State Initialization**: All 8 grouped useState hooks initialize with correct default values
- [ ] **Workflow State**: currentStep starts as 'config', operationType as 'replace'
- [ ] **Table State**: selectedTable defaults to 'word_forms', selectedColumn to 'metadata' 
- [ ] **Record State**: All selection arrays start empty
- [ ] **Metadata State**: Error handling and loading states work correctly
- [ ] **Rule State**: Mappings and tag arrays initialize properly
- [ ] **Execution State**: Progress and results tracking works
- [ ] **Debug State**: Console logging captures all state changes
- [ ] **State Updates**: Debug console shows state changes in real-time
- [ ] **No Race Conditions**: Multiple rapid state updates don't cause conflicts

##### Phase 4: Migration Tab - Complete Workflow Testing

###### Step 1: Configuration
- [ ] **Table Selection**: Can select between 'dictionary', 'word_forms', 'word_translations', 'form_translations'
- [ ] **Column Selection**: 'metadata' column is default and selectable
- [ ] **Operation Type**: Can switch between 'replace', 'add', 'remove' operations
- [ ] **State Persistence**: Selections persist when switching between steps
- [ ] **Validation**: Invalid configurations are prevented

###### Step 2: Word Search & Selection 
- [ ] **Search Functionality**: Can search for Italian words (try "essere", "avere", "fare")
- [ ] **Search Results**: Results display with word type and forms/translations count
- [ ] **Word Selection**: Can select dictionary words with visual confirmation
- [ ] **Form Selection**: Can select individual word forms with blue highlighting
- [ ] **Translation Selection**: Can select individual translations with purple highlighting
- [ ] **Multiple Selections**: Can select multiple items across different words
- [ ] **Selection Persistence**: Selections remain when switching tabs or steps

###### Step 3: CRITICAL - Step 2 Metadata Auto-Loading Testing (THE BIG FIX)
- [ ] **Auto-Trigger Forms**: Selecting forms automatically triggers metadata loading
- [ ] **Auto-Trigger Translations**: Selecting translations automatically triggers metadata loading  
- [ ] **Auto-Trigger Dictionary**: Selecting dictionary words automatically triggers metadata loading
- [ ] **Loading Indicators**: Shows loading state during metadata extraction
- [ ] **Real-Time Query**: Actually queries database for current metadata (not cached)
- [ ] **Story 2.3.1 Integration**: Properly extracts from `metadata` JSONB column
- [ ] **Optional Tags Support**: Properly extracts from `optional_tags` text[] column
- [ ] **Legacy Tags Handling**: Handles transition period `tags` text[] if present
- [ ] **Visual Distinction**: Shows üìã for mandatory metadata vs üè∑Ô∏è for optional tags
- [ ] **Error Handling**: Gracefully handles malformed metadata or connection issues
- [ ] **No Disappearing Data**: Metadata remains loaded and visible (OLD BUG FIXED)
- [ ] **Edit Mode Preservation**: When editing existing rules, previously selected tags are preserved
- [ ] **Performance**: Metadata loading completes within 2 seconds

###### Step 4: Tag Selection & Metadata Display
- [ ] **Mandatory Tags Display**: `metadata.*` keys displayed with structured format
- [ ] **Optional Tags Display**: `optional_tags` array items displayed separately  
- [ ] **Tag Selection**: Can check/uncheck individual tags for migration
- [ ] **Visual Feedback**: Selected tags are clearly highlighted
- [ ] **Combined View**: All available tags from selected records are shown
- [ ] **Source Indication**: Clear indication of which table/column each tag comes from
- [ ] **Count Display**: Accurate count of total selected tags for migration

###### Step 5: Mapping Rules Creation
- [ ] **Add Mapping**: Can add new from‚Üíto mapping pairs
- [ ] **Mapping Input**: Both 'from' and 'to' fields accept text input
- [ ] **Remove Mapping**: Can delete individual mapping pairs
- [ ] **Multiple Mappings**: Can create multiple mapping rules
- [ ] **Validation**: Prevents empty or duplicate mappings
- [ ] **Mapping Persistence**: Rules persist throughout workflow

###### Step 6: Preview Generation (When Implemented)
- [ ] **Preview Accuracy**: Shows exactly what changes will be made
- [ ] **Affected Records**: Displays count and details of affected records
- [ ] **Change Summary**: Clear before/after comparison
- [ ] **Validation**: Prevents execution if preview shows issues

###### Step 7: Execution (When Implemented)
- [ ] **Progress Tracking**: Shows real-time progress during execution
- [ ] **Success Confirmation**: Clear indication when migration completes
- [ ] **Error Handling**: Graceful failure with rollback capabilities
- [ ] **Result Storage**: Execution results are stored for history

##### Phase 5: Audit Tab Testing
- [ ] **Tab Loading**: Audit tab loads without errors
- [ ] **Database Analysis**: Performs real-time database analysis
- [ ] **Tag Consistency**: Checks for tag consistency across tables
- [ ] **Issue Detection**: Identifies and reports database issues
- [ ] **Visual Presentation**: Results are clearly presented with appropriate styling
- [ ] **Refresh Capability**: Can re-run analysis without page reload
- [ ] **Performance**: Analysis completes within reasonable time (under 10 seconds)

##### Phase 6: Progress Tab Testing  
- [ ] **Tab Loading**: Progress tab loads without errors
- [ ] **Execution History**: Displays historical migration executions
- [ ] **Filtering**: Can filter by status, date range, or other criteria
- [ ] **Search**: Can search through execution history
- [ ] **Performance Metrics**: Shows execution times and affected record counts
- [ ] **Revert Capabilities**: Shows rollback options where applicable
- [ ] **Data Persistence**: History persists across sessions

##### Phase 7: Database Integration & Story 2.3.1 Compliance
- [ ] **Schema Compatibility**: Works with current database schema
- [ ] **JSONB Metadata**: Properly handles structured metadata in JSONB format
- [ ] **Text Array Tags**: Correctly processes optional_tags as text arrays
- [ ] **Legacy Support**: Handles transition period with legacy tags column
- [ ] **Type Safety**: No TypeScript errors in production build
- [ ] **Query Performance**: Database queries complete within acceptable timeframes
- [ ] **Connection Resilience**: Handles temporary connection losses gracefully

##### Phase 8: Error Handling & Edge Cases
- [ ] **Network Failures**: Graceful handling of network connectivity issues
- [ ] **Database Timeouts**: Appropriate error messages for slow queries
- [ ] **Empty Results**: Proper handling when searches return no results
- [ ] **Malformed Data**: Resilient to unexpected data formats in database
- [ ] **Invalid Selections**: Prevents invalid user input combinations
- [ ] **Memory Management**: No memory leaks during extended usage
- [ ] **Console Errors**: No unhandled errors or warnings in browser console

##### Phase 9: Performance & User Experience Testing
- [ ] **Load Time**: Page loads within 3 seconds on standard connection
- [ ] **Response Time**: User interactions respond within 500ms
- [ ] **Memory Usage**: Reduced memory footprint compared to old 72 useState version
- [ ] **CPU Usage**: No excessive CPU consumption during normal operation
- [ ] **Smooth Animations**: All UI transitions are smooth and responsive
- [ ] **Accessibility**: Interface is navigable with keyboard and screen readers
- [ ] **Mobile Responsiveness**: Works correctly on mobile devices and tablets

##### Phase 10: Integration & Admin Navigation Testing
- [ ] **Admin Navigation**: Accessible from main admin navigation
- [ ] **URL Routing**: Direct navigation to `/admin/migration-tools` works
- [ ] **Authentication**: Properly respects admin authentication requirements
- [ ] **Session Management**: Maintains session across page refreshes
- [ ] **Return Navigation**: Can navigate back to other admin sections
- [ ] **Breadcrumbs**: Navigation context is clear

##### Phase 11: Cross-Browser & Device Compatibility
- [ ] **Chrome/Chromium**: Full functionality in latest Chrome
- [ ] **Firefox**: Full functionality in latest Firefox  
- [ ] **Safari**: Full functionality in Safari (macOS/iOS)
- [ ] **Edge**: Full functionality in latest Edge
- [ ] **Mobile Chrome**: Touch interactions work correctly
- [ ] **Mobile Safari**: iOS compatibility confirmed
- [ ] **Tablet View**: Interface adapts appropriately for tablet screens

##### Phase 12: Regression Testing (Ensure Nothing Broke)
- [ ] **Existing Features**: All previous migration functionality still works
- [ ] **Database Integrity**: No corruption or data loss from new implementation
- [ ] **Other Admin Features**: Other admin sections unaffected by changes
- [ ] **User Accounts**: User authentication and permissions unchanged
- [ ] **API Endpoints**: No breaking changes to existing API calls
- [ ] **Performance Baseline**: Overall system performance maintained or improved

##### Phase 13: Final Validation & Approval
- [ ] **Complete Workflow Test**: Execute full migration from start to finish
- [ ] **User Acceptance**: User confirms interface meets requirements
- [ ] **Production Readiness**: All tests pass in production-like environment
- [ ] **Documentation Updated**: All changes documented in relevant files
- [ ] **Backup Verification**: Confirm all backup files are intact and accessible
- [ ] **Cleanup Authorization**: User explicitly approves backup file cleanup

**TOTAL TEST SCENARIOS**: 100+ individual test points covering every aspect of the rebuilt system

**TESTING COMPLETION CRITERIA**: 
- ‚úÖ ALL test points must pass
- ‚úÖ User must explicitly approve each phase
- ‚úÖ Production deployment must be stable for 24+ hours
- ‚úÖ No critical issues or regressions identified
- ‚úÖ Backup files must remain until final approval

**ONLY AFTER 100% TESTING COMPLETION**: Consider backup file cleanup with explicit user authorization.

## ACTUAL FUNCTIONAL REQUIREMENTS (ULTRATHINK ADDITION)

**CRITICAL**: The interface must be a working tool, not a demonstration. Remove all story-specific UI clutter and focus on real functionality.

### Core Functional Requirements

#### 1. Rule Management System
- **Save Rules**: Persist migration rules to `custom_migration_rules` Supabase table
- **Load Rules**: Retrieve and restore saved rules with full state
- **Edit Rules**: Modify existing rules and update in database
- **Archive Rules**: Soft delete with revert capabilities
- **Rule Metadata**: Store rule name, description, creation date, last execution
- **Rule Configuration**: Table target, column target, operation type, record filters, mappings

#### 2. Database Record Selection & Management
- **Multi-Table Selection**: Select records across dictionary, word_forms, word_translations, form_translations simultaneously
- **Cross-Table Operations**: Apply same rule across multiple tables in single execution
- **Bulk Operations**: Select/deselect large record sets efficiently
- **Word Card Execution**: Direct execute buttons on individual word cards for immediate action
- **Selection Persistence**: Maintain selections across page refreshes and navigation

#### 3. Live Database Integration (NO MOCK DATA)
- **Real-Time Metadata Extraction**: Connect to actual Supabase tables
- **Live Record Search**: Search actual dictionary words, forms, translations
- **Current Data Display**: Show actual metadata, optional_tags, legacy tags from database
- **Immediate Updates**: Changes reflect immediately in interface
- **Connection Health**: Real-time connection status and error handling

#### 4. Execution & History System
- **Direct Execution**: Execute migrations immediately from interface
- **Execution Logging**: Log all executions to database with full audit trail
- **Revert Capabilities**: Full rollback of executed migrations from history
- **Progress Tracking**: Real-time progress during long-running operations
- **Batch Execution**: Execute multiple rules in sequence
- **Execution Results**: Show exact changes made with before/after values

#### 5. Advanced Selection Modes
- **Global Tag Selection**: Select ALL records containing specific tags across all tables
- **Cross-Table Tag Operations**: "Find all records with tag X in any table"
- **Bulk Tag Operations**: "Replace tag Y with Z across all selected records in all tables"
- **Advanced Filters**: Filter by metadata structure, tag patterns, record counts
- **Selection Analytics**: Show impact analysis before execution

#### 6. User Experience Requirements
- **Clean Interface**: NO story-specific details (72‚Üí8 hooks, phase completion, etc.)
- **Immediate Feedback**: All interactions respond within 500ms
- **Error Recovery**: Graceful handling of connection issues and data conflicts
- **Undo Capability**: Multi-level undo for interface actions
- **Keyboard Shortcuts**: Power-user keyboard navigation
- **Export/Import**: Export rules and selections for backup/sharing

### Database Schema Requirements

#### `custom_migration_rules` Table Structure
```sql
CREATE TABLE custom_migration_rules (
  rule_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  rule_config JSONB NOT NULL, -- Full rule configuration
  transformation JSONB NOT NULL, -- Mapping rules and operations
  target_tables TEXT[] NOT NULL, -- Multiple tables supported
  status VARCHAR(50) DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  last_executed_at TIMESTAMP,
  execution_count INTEGER DEFAULT 0,
  created_by UUID, -- User tracking
  tags TEXT[] DEFAULT '{}' -- Rule categorization
);
```

#### `migration_execution_history` Table Structure  
```sql
CREATE TABLE migration_execution_history (
  execution_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  rule_id UUID REFERENCES custom_migration_rules(rule_id),
  execution_type VARCHAR(50) NOT NULL, -- 'execute', 'revert'
  affected_tables TEXT[] NOT NULL,
  records_affected INTEGER NOT NULL,
  changes_made JSONB NOT NULL, -- Before/after values
  execution_status VARCHAR(50) NOT NULL, -- 'success', 'failed', 'partial'
  execution_time INTERVAL,
  executed_at TIMESTAMP DEFAULT NOW(),
  executed_by UUID,
  error_details JSONB, -- If failed
  revert_data JSONB -- Data needed for rollback
);
```

### Implementation Priority

#### Phase 1: Core Database Integration (CRITICAL)
1. **Remove UI Clutter**: Strip out all story-specific status cards and metrics
2. **Real Database Connections**: Replace ALL mock data with live Supabase queries
3. **Rule Save/Load**: Implement `custom_migration_rules` table operations
4. **Basic Execution**: Simple rule execution with database updates

#### Phase 2: Advanced Selection & Execution
1. **Cross-Table Selection**: Multi-table record selection interface
2. **Global Tag Operations**: Select records by tag across all tables
3. **Execution History**: Real execution logging and revert capabilities
4. **Word Card Actions**: Direct execute buttons on search results

#### Phase 3: Power User Features
1. **Advanced Filters**: Complex record filtering and selection
2. **Batch Operations**: Multi-rule execution sequences
3. **Export/Import**: Rule and selection backup/restore
4. **Performance Optimization**: Handle large datasets efficiently

### Success Criteria (REVISED)

**Functional Success**:
- ‚úÖ Can save, load, edit, and execute real migration rules
- ‚úÖ Can select and modify records across multiple tables simultaneously  
- ‚úÖ Can revert executed migrations from history
- ‚úÖ All operations use live database data (NO mock data)
- ‚úÖ Can execute migrations directly from word search results
- ‚úÖ Clean, professional interface without development artifacts

**Technical Success**:
- ‚úÖ All data operations connect to actual Supabase tables
- ‚úÖ Rules persist across sessions and users
- ‚úÖ Execution history provides full audit trail with rollback capability
- ‚úÖ Interface responds quickly to all user interactions
- ‚úÖ Graceful error handling for all database operations

**User Success**: 
- ‚úÖ Can accomplish real migration tasks without switching tools
- ‚úÖ Can trust the system to safely modify production data
- ‚úÖ Can recover from mistakes using built-in revert capabilities
- ‚úÖ Can work efficiently with large datasets and complex rules

---

## Comprehensive Migration Tools Architecture Requirements

*Based on database analysis, backup files review, and existing saved rules examination - updated for Story 2.3.1 unified metadata structure*

### Overview: The Modern Two-Field Tag System

The migration tools operate exclusively with the **sophisticated two-field tag system** introduced in Story 2.3.1. This creates a clean, powerful architecture for tag management:

**Modern Tag Structure (Story 2.3.1 Implementation)**:
- `metadata` (JSONB) - **Core structured semantic data** with hierarchical organization
- `optional_tags` (text[]) - **Secondary contextual tags** as simple array
- `tags` (text[]) - **Backup field only** - completely ignored by the interface

**Interface Focus**: The tools serve a **single clear purpose**:
- **Sophisticated Management**: Advanced operations on the modern `metadata` + `optional_tags` structure across four database hierarchy levels

### Hierarchical Tag Management Architecture

The system operates exclusively across **four sophisticated database levels**, each utilizing the clean two-field structure for different semantic purposes:

#### Level 1: Dictionary Words (`dictionary` table)
**Purpose**: Word-level classification and core linguistic properties

**Modern Tag Structure**:
```sql
-- Core semantic properties (highly structured JSONB)
metadata: {
  "cefr_level": "A2",
  "word_type": "VERB", 
  "conjugation_pattern": "are-conjugation",
  "auxiliary": "avere",
  "transitivity": "transitive",
  "frequency_rank": 500,
  "register": "standard"
}

-- Secondary contextual tags (simple text array)
optional_tags: ["informal", "regional-northern", "archaic", "colloquial"]
```

**Management Operations**:
- **Metadata Standardization**: Ensure consistent `cefr_level` values across all words
- **Auxiliary Classification**: Structure auxiliary verb requirements in metadata
- **Cross-Field Operations**: Sync important metadata values to optional_tags for search

#### Level 2: Word Forms (`word_forms` table)  
**Purpose**: Conjugation and grammatical form-specific classification

**Modern Tag Structure**:
```sql
-- Grammatical properties (highly structured JSONB)
metadata: {
  "tense": "passato-prossimo",
  "person": "seconda-persona", 
  "number": "singolare",
  "mood": "indicativo",
  "formality": "tu",
  "construction": "compound",
  "regularity": "regular"
}

-- Form-specific modifiers (simple text array)
optional_tags: ["irregular", "alternative-form", "rare", "dialectal"]
```

**Management Operations**:
- **Grammatical Consistency**: Standardize person/number/tense terminology 
- **Form Classification**: Organize irregular vs regular patterns
- **Contextual Tagging**: Add pedagogical or usage notes via optional_tags

#### Level 3: Word Translations (`word_translations` table)
**Purpose**: Translation context and usage information

**Modern Tag Structure**:
```sql
-- Translation context and semantic information (structured JSONB)
metadata: {
  "auxiliary_required": "avere",
  "usage_context": "formal",
  "translation_type": "primary",
  "semantic_field": "communication",
  "register": "standard",
  "frequency": "common"
}

-- Contextual modifiers (simple text array)
optional_tags: ["idiomatic", "literal", "technical", "figurative"]
```

**Management Operations**:
- **Context Standardization**: Ensure consistent auxiliary and register classification
- **Semantic Organization**: Structure translations by usage context and semantic fields
- **Usage Classification**: Organize by formality, context, and frequency

#### Level 4: Form Translations (`form_translations` table)
**Purpose**: Specific form-to-translation context mapping

**Modern Tag Structure**:
```sql
-- Form-specific translation context (structured JSONB)
metadata: {
  "construction_type": "compound", 
  "temporal_reference": "past",
  "aspectual_meaning": "completed",
  "pedagogical_priority": "high"
}

-- Translation-specific modifiers (simple text array)  
optional_tags: ["pedagogical", "simplified", "advanced"]
```

**Management Operations**:
- **Construction Analysis**: Classify simple vs compound constructions
- **Pedagogical Organization**: Structure by learning priority and complexity

### Advanced Rule Targeting System

The migration tools support **precise multi-dimensional targeting** within the clean two-field architecture:

#### A. Modern Field Targeting
Users specify **which modern field** they want to modify:

```typescript
interface ModernRuleTarget {
  field: 'metadata' | 'optional_tags' | 'both_fields';
  table: 'dictionary' | 'word_forms' | 'word_translations' | 'form_translations' | 'all_tables';
  
  // For metadata (JSONB) targeting - supports nested paths
  metadataPath?: string; // e.g., "cefr_level", "person", "auxiliary", "grammar.tense"
  
  // For cross-field synchronization  
  syncBetweenFields?: boolean; // Sync metadata values to optional_tags
}
```

#### B. Sophisticated Cross-Level Selection  
Based on analysis of existing saved rules, users need advanced selection within the modern structure:

```typescript
interface ModernSelectionCriteria {
  // Word-level selection (dictionary table)
  selectedWords: string[]; // ["finire", "parlare"] 
  
  // Form-level precision (word_forms table)
  selectedFormIds: string[]; // Specific conjugated forms
  selectedFormTexts: string[]; // ["hai parlato", "finendo"]
  
  // Translation-level targeting (word_translations table)
  selectedTranslationIds: string[];
  selectedTranslations: string[]; // ["to finish", "to end"]
  
  // Modern tag-based global selection
  tagCriteria: {
    field: 'metadata' | 'optional_tags';
    metadataPath?: string; // For JSONB path queries like "cefr_level" or "grammar.person"
    value: any;
    operator: 'equals' | 'contains' | 'starts_with' | 'in_array' | 'jsonb_path_exists';
  }[];
  
  // Cross-table operations  
  tableScope: 'single' | 'selected' | 'all_tables';
  selectedTables: ('dictionary' | 'word_forms' | 'word_translations' | 'form_translations')[];
}
```

#### C. Modern Precision Targeting Examples 

Real-world examples showing the sophisticated operations within the modern structure:

```typescript
// Example 1: CEFR Level Standardization Across All Tables
{
  name: "Standardize CEFR Levels to A2 Format",
  target: {
    field: "metadata",
    table: "all_tables",
    metadataPath: "cefr_level",
    criteria: [
      { field: "metadata", metadataPath: "cefr_level", value: "CEFR-A2", operator: "equals" }
    ]
  },
  transformation: {
    type: "metadata_standardization",
    operations: [
      { path: "cefr_level", value: "A2" }, // Clean format
      { syncToOptionalTags: "A2" } // Cross-field sync for searchability
    ]
  }
}

// Example 2: Word-Specific Form Grammar Standardization  
{
  name: "Finire Forms - Person Standardization",
  target: {
    field: "metadata",
    table: "word_forms", 
    selectedWords: ["finire"],
    selectedFormIds: ["a39c88ea-874f-4041-94e6-ed4bfbb44f23"], // "finisco"
    metadataPath: "person"
  },
  transformation: {
    type: "metadata_update",
    operations: [
      { path: "person", value: "prima-persona" }, // Standardized grammatical term
      { path: "formality", value: "informal" } // Additional context
    ]
  }
}

// Example 3: Translation Context Enhancement
{
  name: "Add Auxiliary Context to Parlare Translations", 
  target: {
    field: "both_fields",
    table: "word_translations",
    selectedWords: ["parlare"],
    selectedTranslationIds: ["1a221193-3182-49e8-b4ad-da194866e122"]
  },
  transformation: {
    type: "cross_field_enhancement",
    operations: [
      { field: "metadata", path: "auxiliary_required", value: "avere" },
      { field: "metadata", path: "usage_context", value: "standard" },
      { field: "optional_tags", add: ["avere", "transitive"] }
    ]
  }
}

// Example 4: Cross-Table Consistency Operation
{
  name: "Ensure Auxiliary Consistency Across Word Hierarchy",
  target: {
    field: "metadata", 
    table: "all_tables",
    selectedWords: ["parlare"],
    metadataPath: "auxiliary"
  },
  transformation: {
    type: "hierarchical_sync",
    operations: [
      { table: "dictionary", path: "auxiliary", value: "avere" },
      { table: "word_forms", path: "auxiliary_context", value: "avere" },
      { table: "word_translations", path: "auxiliary_required", value: "avere" },
      { crossSync: { from: "metadata.auxiliary", to: "optional_tags" } }
    ]
  }
}
```

### Advanced Transformation Operations for Modern Structure

The transformation system handles sophisticated operations within the clean two-field architecture:

#### 1. Metadata (JSONB) Operations  
**Purpose**: Advanced structured data manipulation

```typescript
interface MetadataTransformations {
  type: 'metadata_operation';
  operations: [
    {
      action: 'set' | 'merge' | 'update' | 'delete' | 'restructure';
      path: string; // JSON path like 'cefr_level' or 'grammar.person' or 'nested.property'
      value: any;
      condition?: { path: string, operator: string, value: any }; // Conditional updates
      backup?: boolean; // Create backup before modification
    }
  ];
}

// Example: Complex nested metadata operations
{
  type: 'metadata_operation',
  operations: [
    { action: 'set', path: 'cefr_level', value: 'A2' },
    { action: 'merge', path: 'grammar', value: { person: 'prima-persona', number: 'singolare' } },
    { action: 'update', path: 'frequency_rank', value: 450, condition: { path: 'frequency_rank', operator: 'greater_than', value: 500 } }
  ]
}
```

#### 2. Optional Tags Array Operations
**Purpose**: Flexible secondary tag management

```typescript
interface OptionalTagsTransformations {
  type: 'optional_tags_operation';
  operations: [
    {
      action: 'add' | 'remove' | 'replace' | 'clear' | 'deduplicate';
      values?: string[]; // For add/remove operations
      replacements?: { from: string, to: string }[]; // For replace operations
      condition?: { field: 'metadata' | 'optional_tags', path?: string, value: any };
    }
  ];
}

// Example: Advanced optional_tags operations
{
  type: 'optional_tags_operation',
  operations: [
    { action: 'add', values: ['regional-northern', 'colloquial'] },
    { action: 'remove', values: ['old-tag', 'deprecated'] },
    { action: 'replace', replacements: [{ from: 'archaic', to: 'historical' }] },
    { action: 'deduplicate' } // Remove duplicates
  ]
}
```

#### 3. Cross-Field Synchronization
**Purpose**: Keep metadata and optional_tags coordinated

```typescript
interface CrossFieldSync {
  type: 'cross_field_sync';
  operations: [
    {
      direction: 'metadata_to_optional' | 'optional_to_metadata' | 'bidirectional';
      source: { field: 'metadata' | 'optional_tags', path?: string };
      target: { field: 'metadata' | 'optional_tags', path?: string };
      syncRule: 'source_priority' | 'target_priority' | 'merge' | 'conditional';
      transformation?: (value: any) => any; // Value transformation during sync
      condition?: { path: string, operator: string, value: any };
    }
  ];
}

// Example: Sync CEFR levels between metadata and optional_tags
{
  type: 'cross_field_sync',
  operations: [
    {
      direction: 'metadata_to_optional',
      source: { field: 'metadata', path: 'cefr_level' },
      target: { field: 'optional_tags' },
      syncRule: 'source_priority',
      transformation: (value) => `level-${value.toLowerCase()}` // A2 ‚Üí level-a2
    }
  ]
}
```

#### 4. Standardization and Consistency Operations
**Purpose**: Ensure data quality and consistency across tables

```typescript
interface StandardizationTransform {
  type: 'standardization';
  scope: 'single_table' | 'cross_table' | 'hierarchical';
  operations: [
    {
      field: 'metadata' | 'optional_tags';
      path?: string; // For metadata JSONB paths
      standardizeValues?: { [oldValue: string]: string }; // Value mappings
      standardizeFormat?: 'lowercase' | 'uppercase' | 'title_case' | 'snake_case';
      validateAgainst?: string[]; // Allowed values list
      createSuggestions?: boolean; // Generate standardization suggestions
    }
  ];
}

// Example: Standardize person values across all word_forms
{
  type: 'standardization',
  scope: 'single_table',
  operations: [
    {
      field: 'metadata',
      path: 'person',
      standardizeValues: {
        'io': 'prima-persona',
        '1st-person': 'prima-persona',
        'I': 'prima-persona',
        'first': 'prima-persona'
      },
      validateAgainst: ['prima-persona', 'seconda-persona', 'terza-persona']
    }
  ]
}
```

#### 5. Hierarchical Operations 
**Purpose**: Coordinate changes across the word ‚Üí forms ‚Üí translations hierarchy

```typescript
interface HierarchicalTransform {
  type: 'hierarchical_operation';
  cascadeDirection: 'top_down' | 'bottom_up' | 'bidirectional';
  operations: [
    {
      level: 'dictionary' | 'word_forms' | 'word_translations' | 'form_translations';
      field: 'metadata' | 'optional_tags';
      path?: string;
      action: 'propagate' | 'synchronize' | 'validate' | 'merge';
      value?: any;
      condition?: { sourceLevel: string, sourcePath: string, sourceValue: any };
    }
  ];
}

// Example: Propagate auxiliary verb info from dictionary to all related records
{
  type: 'hierarchical_operation',
  cascadeDirection: 'top_down',
  operations: [
    {
      level: 'dictionary',
      field: 'metadata',
      path: 'auxiliary',
      action: 'propagate',
      value: 'avere'
    },
    {
      level: 'word_translations',
      field: 'metadata', 
      path: 'auxiliary_required',
      action: 'synchronize',
      condition: { sourceLevel: 'dictionary', sourcePath: 'auxiliary', sourceValue: 'avere' }
    }
  ]
}
```

### Interactive Word Card System Requirements

The interface recreates the sophisticated **clickable selection system** optimized for the modern two-field structure:

#### A. Modern Word Card Display Structure
```typescript
interface ModernWordCard {
  // Word information (dictionary table)
  word: {
    italian: string;
    wordId: string;
    
    // Core structured data (metadata JSONB)
    coreMetadata: {
      cefr_level?: string;
      word_type?: string; 
      conjugation_pattern?: string;
      auxiliary?: string;
      transitivity?: string;
      frequency_rank?: number;
      register?: string;
    };
    
    // Secondary tags (optional_tags text[])
    optionalTags: string[]; // ["informal", "regional-northern", "colloquial"]
  };
  
  // Form selection with modern structure (word_forms table)
  forms: {
    id: string;
    form_text: string;
    
    // Grammatical metadata (metadata JSONB)
    grammarMetadata: {
      tense?: string;
      person?: string;
      number?: string;
      mood?: string;
      formality?: string;
      construction?: string;
      regularity?: string;
    };
    
    // Form modifiers (optional_tags text[])
    optionalTags: string[]; // ["irregular", "alternative-form", "rare"]
    
    selectable: boolean;
    selected: boolean;
  }[];
  
  // Translation selection with modern context (word_translations table)
  translations: {
    id: string;
    translation: string;
    
    // Context metadata (metadata JSONB)
    contextMetadata: {
      auxiliary_required?: string;
      usage_context?: string;
      translation_type?: string;
      semantic_field?: string;
      register?: string;
      frequency?: string;
    };
    
    // Translation modifiers (optional_tags text[])
    optionalTags: string[]; // ["idiomatic", "literal", "technical"]
    
    selectable: boolean;
    selected: boolean;
  }[];
}
```

#### B. Modern Selection Interactions
Users can perform sophisticated selection within the clean two-field system:

1. **Multi-Level Selection**: Click words, forms, and translations simultaneously across hierarchy
2. **Metadata-Based Global Selection**: "Select all records with `metadata.cefr_level = 'A2'`"
3. **Optional Tags Selection**: "Select all records with `optional_tags` containing 'informal'"
4. **Structured Metadata Browsing**: Navigate JSONB hierarchy visually (expandable JSON tree)
5. **Cross-Table Selection**: Select related records across all four tables simultaneously
6. **Smart Filtering**: Filter by metadata paths or optional_tags values with autocomplete
7. **Bulk Operations**: Select hundreds of records efficiently for batch operations

#### C. Clean Visual Differentiation System
The interface clearly distinguishes between the two modern field types:

```typescript
interface ModernTagDisplayRules {
  metadata: {
    style: "border-blue-500 bg-blue-50", // Structured data - blue
    icon: "üìã",
    label: "Core Metadata", 
    expandable: true, // Show JSONB structure as collapsible tree
    searchable: true, // Search within JSON paths
    editable: true // Inline editing of metadata values
  };
  optional_tags: {
    style: "border-green-500 bg-green-50", // Simple tags - green  
    icon: "üè∑Ô∏è",
    label: "Optional Tags",
    expandable: false, // Simple array display
    searchable: true, // Search tag values
    editable: true // Add/remove tags inline
  };
}
```

### Modern Database Integration Requirements

The system operates exclusively with the clean two-field architecture:

#### A. Modern Schema Operations
```sql
-- Query system works with ONLY the two active fields
-- Example: Find all records needing CEFR standardization

-- Search metadata JSONB field (structured queries)
WHERE metadata->>'cefr_level' IN ('CEFR-A2', 'CEFR-A1', 'A-2', 'level-A2')
   OR metadata->'grammar'->>'level' LIKE 'CEFR-%'
  
-- Search optional_tags array (simple array queries)
OR 'CEFR-A2' = ANY(optional_tags)
OR 'level-A2' = ANY(optional_tags)

-- Combined cross-field searches
OR (metadata->>'cefr_level' IS NOT NULL AND 'A2' = ANY(optional_tags));
```

#### B. Advanced JSONB Operations for Metadata
The system leverages PostgreSQL's advanced JSONB capabilities:

```sql
-- Nested metadata queries
WHERE metadata->'grammar'->>'person' = 'prima-persona'
  AND metadata->'grammar'->>'number' = 'singolare'

-- JSON path expressions  
WHERE metadata @@ '$.cefr_level == "A2"'
   OR metadata @@ '$.grammar.tense == "passato-prossimo"'

-- Metadata update operations
UPDATE word_forms 
SET metadata = metadata || '{"person": "prima-persona", "updated": true}'
WHERE metadata->>'person' = 'io'

-- Complex metadata restructuring
UPDATE dictionary 
SET metadata = metadata - 'old_field' || jsonb_build_object('new_field', metadata->>'old_field')
WHERE metadata ? 'old_field'
```

#### C. Execution History for Modern Operations
Enhanced tracking for the two-field system:

```sql
-- Modern execution history tracking
CREATE TABLE migration_execution_history (
  execution_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  rule_id UUID REFERENCES custom_migration_rules(rule_id),
  
  -- Track modern field operations
  metadata_changes JSONB, -- Before/after metadata JSONB changes
  optional_tags_changes JSONB, -- Before/after optional_tags array changes
  
  -- Field-specific tracking
  metadata_paths_modified TEXT[], -- Which JSONB paths were changed
  optional_tags_added TEXT[], -- Tags added to optional_tags
  optional_tags_removed TEXT[], -- Tags removed from optional_tags
  
  -- Cross-field operations
  sync_operations JSONB, -- Metadata ‚Üî optional_tags synchronization actions
  
  -- Standard fields
  affected_tables TEXT[],
  records_affected INTEGER,
  execution_status TEXT,
  executed_at TIMESTAMP DEFAULT NOW(),
  
  -- Complete revert capability
  revert_data JSONB -- Full before state for rollback
);

-- Indexes for performance
CREATE INDEX idx_execution_history_metadata_paths ON migration_execution_history 
  USING GIN(metadata_paths_modified);
CREATE INDEX idx_execution_history_optional_tags ON migration_execution_history 
  USING GIN(optional_tags_added, optional_tags_removed);
```

#### D. Rule Conversion Requirements
Existing saved rules need systematic conversion from legacy format:

```typescript
interface RuleConversionTask {
  purpose: 'Convert existing saved rules from legacy column targeting to modern field targeting';
  
  conversionMappings: {
    // Legacy column references ‚Üí Modern field references
    'tags': 'optional_tags', // Simple array migration
    'context_metadata': 'metadata', // Structured data migration
    'column: tags': 'field: optional_tags',
    'column: context_metadata': 'field: metadata'
  };
  
  transformationUpdates: {
    // Legacy transformation types ‚Üí Modern transformation types  
    'array_replace': 'optional_tags_operation + metadata_operation',
    'array_add': 'optional_tags_operation',
    'migrate_to_metadata': 'metadata_operation + cross_field_sync'
  };
  
  patternUpdates: {
    // Legacy pattern matching ‚Üí Modern pattern matching
    'targetTags': 'tagCriteria with field: optional_tags',
    'targetWords + targetTags': 'selectedWords + tagCriteria',
    'table + column': 'table + field'
  };
}

### Implementation Architecture Summary

The rebuilt migration tools are a **sophisticated modern tag management system** that:

1. **Handles Clean Two-Field Structure**: Seamlessly operates with `metadata` (JSONB) and `optional_tags` (text[]) - completely ignoring legacy fields

2. **Provides Hierarchical Management**: Enables precise control across dictionary ‚Üí word_forms ‚Üí word_translations ‚Üí form_translations hierarchy using modern fields

3. **Supports Advanced Operations**: Complex JSONB metadata operations, optional_tags array management, and cross-field synchronization

4. **Enables Sophisticated Targeting**: Word-specific, form-specific, translation-specific, and global operations within the modern structure

5. **Ensures Data Quality**: Standardization, validation, and consistency tools for the two-field system

6. **Offers Clean Visual Interface**: Clear distinction between structured metadata (üìã blue) and simple optional tags (üè∑Ô∏è green)

7. **Maintains Complete Audit Trail**: Detailed tracking of metadata path changes, optional_tags modifications, and full rollback capability

8. **Includes Rule Conversion Task**: Systematic conversion of existing saved rules from legacy format to modern field targeting

The system is a **comprehensive modern tag database management interface** that leverages the full power of PostgreSQL's JSONB capabilities while providing an intuitive interface for managing the hierarchical tag taxonomy across the four-level database structure.

## Thorough Implementation Plan

*Comprehensive step-by-step plan for building the modern migration tools interface*

### Phase 0: Foundation & Preparation (2-3 hours)

#### Step 0.1: Database Schema Validation (30 minutes)
```sql
-- Verify modern field structure across all tables
SELECT table_name, column_name, data_type 
FROM information_schema.columns 
WHERE table_schema = 'public' 
AND table_name IN ('dictionary', 'word_forms', 'word_translations', 'form_translations')
AND column_name IN ('metadata', 'optional_tags')
ORDER BY table_name, column_name;

-- Verify custom_migration_rules exists and update structure if needed
ALTER TABLE custom_migration_rules 
ADD COLUMN IF NOT EXISTS modern_target_fields JSONB,
ADD COLUMN IF NOT EXISTS modern_transformation JSONB;
```

#### Step 0.2: Clean Page Structure (30 minutes)
```typescript
// /app/admin/migration-tools/page.tsx - COMPLETELY CLEAN
'use client';

import MigrationTools from './components/MigrationTools';

export default function MigrationToolsPage() {
  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900">Migration Tools</h1>
          <p className="mt-2 text-gray-600">Modern tag and metadata management interface</p>
        </div>
        <MigrationTools />
      </div>
    </div>
  );
}
```

#### Step 0.3: Modern Database Service Foundation (1 hour)
```typescript
// /app/admin/migration-tools/services/ModernDatabaseService.ts
class ModernMigrationService {
  private supabase = createClientComponentClient();
  
  // Modern field queries - ONLY metadata and optional_tags
  async searchRecordsByMetadata(table: string, path: string, value: any) {
    return await this.supabase
      .from(table)
      .select('*')
      .eq(path.startsWith('metadata.') ? `metadata->${path.slice(9)}` : path, value);
  }
  
  async searchRecordsByOptionalTags(table: string, tagValue: string) {
    return await this.supabase
      .from(table) 
      .select('*')
      .contains('optional_tags', [tagValue]);
  }
  
  // Cross-table modern searches
  async searchAcrossTables(criteria: ModernSelectionCriteria) {
    const tables = ['dictionary', 'word_forms', 'word_translations', 'form_translations'];
    const results = {};
    
    for (const table of tables) {
      if (criteria.field === 'metadata' && criteria.metadataPath) {
        results[table] = await this.searchRecordsByMetadata(table, criteria.metadataPath, criteria.value);
      } else if (criteria.field === 'optional_tags') {
        results[table] = await this.searchRecordsByOptionalTags(table, criteria.value);
      }
    }
    
    return results;
  }
  
  // Rule persistence in modern format
  async saveModernRule(rule: ModernMigrationRule) {
    return await this.supabase
      .from('custom_migration_rules')
      .insert({
        name: rule.name,
        description: rule.description,
        modern_target_fields: rule.target,
        modern_transformation: rule.transformation,
        target_tables: rule.target.selectedTables,
        status: 'active'
      });
  }
  
  async loadModernRules() {
    return await this.supabase
      .from('custom_migration_rules') 
      .select('*')
      .eq('status', 'active')
      .not('modern_target_fields', 'is', null); // Only modern rules
  }
}
```

#### Step 0.4: Modern State Architecture (1 hour)
```typescript
// Clean grouped state management - NO 72 useState hooks
interface MigrationToolsState {
  // UI state
  ui: {
    activeTab: 'rules' | 'search' | 'history';
    showSaveModal: boolean;
    showLoadModal: boolean;
    isLoading: boolean;
    error: string | null;
  };
  
  // Search and selection state
  selection: {
    searchTerm: string;
    searchMode: 'metadata' | 'optional_tags' | 'both';
    metadataPath: string; // For JSONB path queries
    selectedWords: string[];
    selectedFormIds: string[];
    selectedTranslationIds: string[];
    searchResults: ModernWordCard[];
  };
  
  // Rule building state
  ruleBuilder: {
    ruleName: string;
    ruleDescription: string;
    targetField: 'metadata' | 'optional_tags' | 'both';
    targetTables: string[];
    transformationType: 'metadata_operation' | 'optional_tags_operation' | 'cross_field_sync';
    operations: any[];
  };
  
  // Execution state
  execution: {
    executionHistory: ExecutionRecord[];
    isExecuting: boolean;
    lastExecutionResult: any;
  };
}
```

### Phase 1: Core Interface Components (4-5 hours)

#### Step 1.1: Modern Search Interface (2 hours)
```typescript
// /components/SearchInterface.tsx
export default function ModernSearchInterface() {
  const [searchState, setSearchState] = useState({
    searchTerm: '',
    searchMode: 'metadata' as 'metadata' | 'optional_tags' | 'both',
    metadataPath: 'cefr_level', // Default path
    results: [] as ModernWordCard[]
  });
  
  const handleModernSearch = async () => {
    const service = new ModernMigrationService();
    
    if (searchState.searchMode === 'metadata') {
      // Search in JSONB metadata field
      const results = await service.searchAcrossTables({
        field: 'metadata',
        metadataPath: searchState.metadataPath,
        value: searchState.searchTerm
      });
      setSearchState(prev => ({ ...prev, results: formatWordCards(results) }));
      
    } else if (searchState.searchMode === 'optional_tags') {
      // Search in optional_tags array
      const results = await service.searchAcrossTables({
        field: 'optional_tags',
        value: searchState.searchTerm
      });
      setSearchState(prev => ({ ...prev, results: formatWordCards(results) }));
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Modern Search Controls */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Search Field</label>
            <select
              value={searchState.searchMode}
              onChange={(e) => setSearchState(prev => ({ ...prev, searchMode: e.target.value as any }))}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
            >
              <option value="metadata">üìã Core Metadata (JSONB)</option>
              <option value="optional_tags">üè∑Ô∏è Optional Tags (Array)</option>
              <option value="both">Both Fields</option>
            </select>
          </div>
          
          {searchState.searchMode === 'metadata' && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">Metadata Path</label>
              <input
                type="text"
                value={searchState.metadataPath}
                onChange={(e) => setSearchState(prev => ({ ...prev, metadataPath: e.target.value }))}
                placeholder="e.g. cefr_level, person, grammar.tense"
                className="w-full border border-gray-300 rounded-md px-3 py-2"
              />
            </div>
          )}
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Search Value</label>
            <input
              type="text"
              value={searchState.searchTerm}
              onChange={(e) => setSearchState(prev => ({ ...prev, searchTerm: e.target.value }))}
              onKeyPress={(e) => e.key === 'Enter' && handleModernSearch()}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
            />
          </div>
          
          <div className="flex items-end">
            <button
              onClick={handleModernSearch}
              className="w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"
            >
              Search Modern Fields
            </button>
          </div>
        </div>
      </div>
      
      {/* Modern Word Cards Display */}
      <div className="space-y-4">
        {searchState.results.map((wordCard) => (
          <ModernWordCard key={wordCard.word.wordId} wordCard={wordCard} />
        ))}
      </div>
    </div>
  );
}
```

#### Step 1.2: Modern Word Card Component (2 hours)
```typescript
// /components/ModernWordCard.tsx  
export default function ModernWordCard({ wordCard }: { wordCard: ModernWordCard }) {
  const [selectedItems, setSelectedItems] = useState({
    word: false,
    forms: new Set<string>(),
    translations: new Set<string>()
  });
  
  return (
    <div className="bg-white border rounded-lg p-4">
      {/* Word Level */}
      <div className="mb-4">
        <div className="flex items-center space-x-3 mb-2">
          <input
            type="checkbox"
            checked={selectedItems.word}
            onChange={(e) => setSelectedItems(prev => ({ ...prev, word: e.target.checked }))}
          />
          <h3 className="text-lg font-medium">{wordCard.word.italian}</h3>
        </div>
        
        {/* Core Metadata Display (Blue) */}
        <div className="border-blue-500 bg-blue-50 rounded p-3 mb-2">
          <div className="flex items-center space-x-2 mb-2">
            <span className="text-blue-600">üìã</span>
            <span className="text-sm font-medium text-blue-900">Core Metadata</span>
          </div>
          <div className="text-sm space-y-1">
            {Object.entries(wordCard.word.coreMetadata).map(([key, value]) => (
              <div key={key} className="flex">
                <span className="text-blue-700 font-medium w-24">{key}:</span>
                <span className="text-blue-800">{String(value)}</span>
              </div>
            ))}
          </div>
        </div>
        
        {/* Optional Tags Display (Green) */}
        <div className="border-green-500 bg-green-50 rounded p-3">
          <div className="flex items-center space-x-2 mb-2">
            <span className="text-green-600">üè∑Ô∏è</span>
            <span className="text-sm font-medium text-green-900">Optional Tags</span>
          </div>
          <div className="flex flex-wrap gap-1">
            {wordCard.word.optionalTags.map((tag) => (
              <span key={tag} className="bg-green-200 text-green-800 px-2 py-1 rounded text-xs">
                {tag}
              </span>
            ))}
          </div>
        </div>
      </div>
      
      {/* Forms and Translations with same modern structure... */}
    </div>
  );
}
```

### Phase 2: Rule Management System (3-4 hours)

#### Step 2.1: Modern Rule Builder (2 hours)
```typescript
// /components/ModernRuleBuilder.tsx
export default function ModernRuleBuilder() {
  const [ruleState, setRuleState] = useState({
    name: '',
    description: '',
    targetField: 'metadata' as 'metadata' | 'optional_tags' | 'both',
    metadataPath: '',
    targetTables: ['dictionary'] as string[],
    operations: [] as any[]
  });
  
  const addMetadataOperation = () => {
    setRuleState(prev => ({
      ...prev,
      operations: [...prev.operations, {
        type: 'metadata_operation',
        action: 'set',
        path: ruleState.metadataPath,
        value: ''
      }]
    }));
  };
  
  const addOptionalTagsOperation = () => {
    setRuleState(prev => ({
      ...prev,
      operations: [...prev.operations, {
        type: 'optional_tags_operation',
        action: 'add',
        values: []
      }]
    }));
  };
  
  return (
    <div className="space-y-6">
      <div className="bg-gray-50 p-4 rounded-lg">
        <h3 className="text-lg font-medium mb-4">Modern Rule Builder</h3>
        
        {/* Rule Basic Info */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Rule Name</label>
            <input
              type="text"
              value={ruleState.name}
              onChange={(e) => setRuleState(prev => ({ ...prev, name: e.target.value }))}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Target Field</label>
            <select
              value={ruleState.targetField}
              onChange={(e) => setRuleState(prev => ({ ...prev, targetField: e.target.value as any }))}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
            >
              <option value="metadata">üìã Metadata (JSONB)</option>
              <option value="optional_tags">üè∑Ô∏è Optional Tags (Array)</option>
              <option value="both">Both Fields</option>
            </select>
          </div>
        </div>
        
        {/* Operation Builder */}
        <div className="space-x-2">
          <button
            onClick={addMetadataOperation}
            className="bg-blue-600 text-white px-3 py-2 rounded"
          >
            Add Metadata Operation
          </button>
          <button
            onClick={addOptionalTagsOperation}
            className="bg-green-600 text-white px-3 py-2 rounded"
          >
            Add Optional Tags Operation
          </button>
        </div>
        
        {/* Operations List */}
        <div className="mt-4 space-y-2">
          {ruleState.operations.map((op, index) => (
            <ModernOperationEditor key={index} operation={op} />
          ))}
        </div>
      </div>
    </div>
  );
}
```

#### Step 2.2: Rule Persistence and Loading (1 hour)
```typescript
// Rule save/load with modern format
const saveModernRule = async (rule: ModernMigrationRule) => {
  const service = new ModernMigrationService();
  
  const ruleData = {
    name: rule.name,
    description: rule.description,
    modern_target_fields: {
      field: rule.targetField,
      tables: rule.targetTables,
      metadataPath: rule.metadataPath,
      selection: rule.selectionCriteria
    },
    modern_transformation: {
      operations: rule.operations
    }
  };
  
  await service.saveModernRule(ruleData);
};
```

### Phase 3: Execution System (3-4 hours)

#### Step 3.1: Modern Rule Execution Engine (2 hours)
```typescript
// /services/ModernExecutionEngine.ts
class ModernExecutionEngine {
  async executeRule(rule: ModernMigrationRule): Promise<ExecutionResult> {
    const startTime = Date.now();
    const changes = { metadata: {}, optional_tags: {} };
    
    try {
      // Execute metadata operations
      if (rule.operations.some(op => op.type === 'metadata_operation')) {
        const metadataResults = await this.executeMetadataOperations(rule);
        changes.metadata = metadataResults;
      }
      
      // Execute optional_tags operations  
      if (rule.operations.some(op => op.type === 'optional_tags_operation')) {
        const tagsResults = await this.executeOptionalTagsOperations(rule);
        changes.optional_tags = tagsResults;
      }
      
      // Log to execution history
      await this.logExecution({
        rule_id: rule.id,
        metadata_changes: changes.metadata,
        optional_tags_changes: changes.optional_tags,
        execution_time: Date.now() - startTime,
        execution_status: 'success'
      });
      
      return { success: true, changes, recordsAffected: Object.keys(changes).length };
      
    } catch (error) {
      await this.logExecution({
        rule_id: rule.id,
        execution_status: 'failed',
        error_details: error
      });
      throw error;
    }
  }
  
  private async executeMetadataOperations(rule: ModernMigrationRule) {
    const results = {};
    
    for (const table of rule.targetTables) {
      for (const operation of rule.operations) {
        if (operation.type === 'metadata_operation') {
          const { data, error } = await this.supabase
            .from(table)
            .update({
              metadata: this.supabase.raw(`metadata || '${JSON.stringify({ [operation.path]: operation.value })}'`)
            })
            .in('id', rule.selectedRecords[table] || []);
            
          if (error) throw error;
          results[table] = data;
        }
      }
    }
    
    return results;
  }
}
```

#### Step 3.2: Execution History and Revert (1.5 hours)
```typescript
// /components/ExecutionHistory.tsx - Updated for modern operations
export default function ModernExecutionHistory() {
  const [executions, setExecutions] = useState<ExecutionRecord[]>([]);
  
  const loadExecutionHistory = async () => {
    const { data, error } = await supabase
      .from('migration_execution_history')
      .select('*')
      .not('metadata_changes', 'is', null) // Only modern executions
      .order('executed_at', { ascending: false });
      
    if (error) throw error;
    setExecutions(data || []);
  };
  
  const handleRevert = async (execution: ExecutionRecord) => {
    if (!execution.revert_data) {
      alert('No revert data available for this execution.');
      return;
    }
    
    // Revert metadata changes
    if (execution.metadata_changes) {
      await revertMetadataChanges(execution.metadata_changes, execution.revert_data);
    }
    
    // Revert optional_tags changes
    if (execution.optional_tags_changes) {
      await revertOptionalTagsChanges(execution.optional_tags_changes, execution.revert_data);
    }
    
    alert('Revert completed successfully!');
    loadExecutionHistory();
  };
  
  return (
    <div className="space-y-4">
      {/* Execution history display with modern field tracking */}
      {executions.map((execution) => (
        <div key={execution.execution_id} className="bg-white border rounded-lg p-4">
          <div className="flex justify-between items-start">
            <div>
              <h3 className="font-medium">{execution.rule_name}</h3>
              <div className="text-sm text-gray-600 space-y-1">
                <div>Metadata Paths: {execution.metadata_paths_modified?.join(', ') || 'None'}</div>
                <div>Tags Added: {execution.optional_tags_added?.join(', ') || 'None'}</div>
                <div>Tags Removed: {execution.optional_tags_removed?.join(', ') || 'None'}</div>
              </div>
            </div>
            
            <button
              onClick={() => handleRevert(execution)}
              className="bg-yellow-600 text-white px-3 py-1 rounded"
            >
              Revert
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

### Phase 4: Legacy Rule Conversion Task (2-3 hours)

#### Step 4.1: Rule Conversion Service (2 hours)
```typescript
// /services/RuleConversionService.ts
class RuleConversionService {
  async convertLegacyRules() {
    // Get all saved rules with legacy format
    const { data: legacyRules } = await supabase
      .from('custom_migration_rules')
      .select('*')
      .is('modern_target_fields', null); // Legacy rules
    
    for (const legacyRule of legacyRules) {
      const modernRule = this.convertRuleFormat(legacyRule);
      
      // Update with modern format
      await supabase
        .from('custom_migration_rules')
        .update({
          modern_target_fields: modernRule.target,
          modern_transformation: modernRule.transformation,
          status: 'converted'
        })
        .eq('id', legacyRule.id);
    }
  }
  
  private convertRuleFormat(legacyRule: any): ModernMigrationRule {
    const legacy = legacyRule.pattern;
    const transform = legacyRule.transformation;
    
    // Convert field targeting
    let modernField: 'metadata' | 'optional_tags';
    if (legacy.column === 'tags') {
      modernField = 'optional_tags';
    } else if (legacy.column === 'context_metadata') {
      modernField = 'metadata';
    }
    
    // Convert transformation operations
    const modernOperations = [];
    if (transform.type === 'array_replace') {
      if (modernField === 'optional_tags') {
        modernOperations.push({
          type: 'optional_tags_operation',
          action: 'replace',
          replacements: Object.entries(transform.mappings).map(([from, to]) => ({ from, to }))
        });
      } else {
        modernOperations.push({
          type: 'metadata_operation',
          action: 'set',
          path: this.inferMetadataPath(transform.mappings),
          value: Object.values(transform.mappings)[0]
        });
      }
    }
    
    return {
      name: legacyRule.name,
      description: `${legacyRule.description} (Converted from legacy format)`,
      targetField: modernField,
      targetTables: legacyRule.target_tables,
      operations: modernOperations
    };
  }
}
```

### Phase 5: Integration and Testing (2-3 hours)

#### Step 5.1: Main Component Integration (1 hour)
```typescript
// /components/MigrationTools.tsx - Clean modern integration
export default function MigrationTools() {
  const [activeTab, setActiveTab] = useState<'rules' | 'search' | 'history'>('search');
  
  return (
    <div className="bg-white shadow rounded-lg">
      {/* Clean Tab Navigation */}
      <div className="border-b border-gray-200">
        <nav className="flex">
          <TabButton
            id="search"
            name="Search & Execute" 
            icon="üîç"
            active={activeTab === 'search'}
            onClick={setActiveTab}
          />
          <TabButton
            id="rules"
            name="Saved Rules"
            icon="üìã" 
            active={activeTab === 'rules'}
            onClick={setActiveTab}
          />
          <TabButton
            id="history"
            name="Execution History"
            icon="üìä"
            active={activeTab === 'history'}
            onClick={setActiveTab}
          />
        </nav>
      </div>
      
      {/* Tab Content */}
      <div className="p-6">
        {activeTab === 'search' && <ModernSearchInterface />}
        {activeTab === 'rules' && <ModernRuleManager />}
        {activeTab === 'history' && <ModernExecutionHistory />}
      </div>
    </div>
  );
}
```

#### Step 5.2: End-to-End Testing (1-2 hours)
- Test modern field searches across all tables
- Test rule creation, saving, and execution 
- Test execution history and revert functionality
- Test word card selection and rule building
- Test cross-field synchronization operations

### Success Criteria Validation

**Functional Success** ‚úÖ:
- Can search and select records using modern `metadata` and `optional_tags` fields
- Can build sophisticated rules targeting JSONB metadata paths and array operations
- Can execute rules with full audit trail and revert capability
- Can manage cross-table operations and hierarchical synchronization
- All operations ignore legacy `tags` field completely

**Technical Success** ‚úÖ:
- Clean two-field architecture with no legacy dependencies
- Advanced JSONB operations leveraging PostgreSQL capabilities
- Efficient cross-table searches and batch operations
- Complete execution tracking with rollback functionality

**User Success** ‚úÖ:
- Intuitive interface distinguishing between structured metadata and simple tags
- Powerful rule building with visual feedback
- Reliable execution with confidence in revert capability
- Professional interface without development artifacts

---

## Success Metrics

- **Modern Architecture** complete with clean two-field operation
- **Codebase Simplification** removes complex legacy handling code
- **Advanced Functionality** leverages full JSONB capabilities
- **Rule Conversion Task** updates existing saved rules to modern format
- **Complete Audit Trail** with sophisticated revert capabilities
- **Professional Interface** with clear visual distinction between field types
- **Cross-Table Operations** enabling hierarchical tag management

**Complete modern migration tools interface with sophisticated tag management capabilities.**