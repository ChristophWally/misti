# Story 002.003.1: Tag Schema Restructure Migration

**Epic**: Complete Conjugation System Architectural Rebuild

**As a** developer and system architect  
**I want** to restructure the tag schema across all core tables to separate mandatory metadata from optional descriptive tags  
**So that** the system has consistent, structured metadata for generation/interface logic while maintaining flexible tagging for descriptive purposes

---

## Background & Problem Statement

The current tag system has **critical inconsistencies across core tables** that create migration tool complexity and maintenance issues:

### Current State Problems:
- **`dictionary.tags`**: `string[]` with ~200 mixed mandatory + optional tags
- **`word_forms.tags`**: `string[]` with ~300 mixed mandatory + optional tags  
- **`word_translations.context_metadata`**: `jsonb` (already structured - good!)
- **`form_translations`**: No structured metadata system

### Impact on System:
- Migration tools must handle 3 different data formats
- Generation logic scattered across array searches vs object property access
- No clear distinction between "affects functionality" vs "descriptive only" tags
- Complex Step 2 metadata loading due to format inconsistencies
- Difficult to maintain data quality and validation

---

## Solution: Unified Metadata Architecture

### Target Schema (All 4 Core Tables):
```sql
-- Every core table gets BOTH:
metadata jsonb,           -- Mandatory fields affecting functionality  
optional_tags text[]      -- Descriptive tags only
```

### Mandatory Metadata Categories (jsonb):

**Dictionary Table** - Core word properties:
```json
{
  "gender": "masculine|feminine|common-gender",
  "conjugation_type": "are|ere|ire|ire-isc", 
  "auxiliary": "avere|essere|both",
  "transitivity": "transitive|intransitive|both",
  "reflexive": true/false,
  "irregular": true/false,
  "word_form_pattern": "form-4|form-2|irregular",
  "gradable": true/false,
  "frequency_tier": "top100|top500|top1000|top5000",
  "cefr_level": "A1|A2|B1|B2|C1|C2"
}
```

**Word Forms Table** - Grammatical properties:
```json
{
  "mood": "indicativo|congiuntivo|condizionale|imperativo",
  "tense": "presente|imperfetto|passato-prossimo|futuro-semplice|...",
  "person": "prima-persona|seconda-persona|terza-persona",
  "number": "singolare|plurale", 
  "gender": "masculine|feminine",
  "irregular": true/false,
  "compound": true/false,
  "reflexive": true/false,
  "morphological_type": "regular|irregular|suppletive"
}
```

**Word Translations Table** - Already good structure, minor enhancements:
```json
{
  "usage": "primary|secondary|specialized",
  "register": "formal|informal|neutral",
  "context": "general|technical|literary",
  "source": "original-dictionary|generated|user-contributed",
  "gender_usage": "male-only|female-only|both|neutral"
}
```

**Form Translations Table** - New structured metadata:
```json
{
  "assignment_method": "automatic|manual|ai-generated",
  "confidence_score": 0.95,
  "context_specificity": "general|specific|idiomatic",
  "usage_frequency": "common|rare|archaic"
}
```

**Optional Tags** - Descriptive only (examples):
```sql
-- All tables can have descriptive tags like:
["freq-top100", "CEFR-A1", "business", "topic-daily-life", "regional-tuscany", "archaic", "poetic", "beginner-friendly"]
```

---

## Acceptance Criteria

### Schema Migration
- [ ] **Database migration scripts** created for all 4 core tables
- [ ] **Backwards compatibility** maintained during transition period
- [ ] **Data preservation** - zero data loss during migration
- [ ] **Rollback capability** - complete reversion possible if needed

### Data Structure Conversion
- [ ] **Mapping service** created to convert current array tags to new structure
- [ ] **Tag classification** completed - mandatory vs optional tags identified
- [ ] **Data validation** ensures all converted data meets new schema constraints
- [ ] **Edge case handling** for malformed or missing tag data

### System Integration  
- [ ] **Migration tools** updated to work with new jsonb + array structure
- [ ] **Generation logic** updated to use structured metadata fields
- [ ] **UI components** display structured metadata appropriately
- [ ] **Search functionality** works with both jsonb metadata and array tags

### Quality Assurance
- [ ] **Migration verification** - sample data manually verified for accuracy
- [ ] **Performance testing** - no degradation in query performance
- [ ] **Consistency validation** - all tables follow identical patterns
- [ ] **Documentation updated** - new schema documented in tag rules file

---

## Design Decisions & Architectural Rationale

### **Decision 1: Unified Schema Architecture (metadata jsonb + optional_tags text[])**

**What**: Every core table gets identical column structure: `metadata jsonb` + `optional_tags text[]`

**Why**: 
- **Eliminates format inconsistencies**: Current system mixes `string[]` tags with `jsonb` context_metadata, creating complex migration tool logic
- **Simplifies development**: Migration tools can use identical query patterns across all tables
- **Improves maintainability**: Single approach reduces cognitive overhead and bug surface area
- **Enables validation**: jsonb allows database constraints while arrays enable flexible descriptive tags

**Alternative Considered**: Table-specific naming (`word_metadata`, `form_metadata`) 
**Rejected Because**: Creates unnecessary complexity and cognitive overhead for developers

### **Decision 2: Mandatory vs Optional Tag Categorization**

**What**: Split functionality-affecting fields (→ jsonb) from descriptive-only fields (→ array)

**Mandatory → jsonb Criteria**:
- **Affects system behavior**: Gender influences UI display, conjugation type determines form generation
- **Required for validation**: CEFR level affects learning progression, auxiliary selection impacts grammatical behavior
- **Enumerable values**: Finite, controlled vocabularies suitable for database constraints

**Optional → array Criteria**:
- **Descriptive only**: Regional markers, style indicators, pedagogical hints
- **No system impact**: Don't affect form generation, UI behavior, or core functionality
- **Open vocabulary**: Can expand organically without schema changes

**Data Analysis Validation**: Current database shows clean separation - all CEFR, gender, conjugation, and mood tags have clear functional roles

### **Decision 3: 27 Unique Tense System**

**What**: Rename ambiguous tenses to unique identifiers (presente → congiuntivo-presente, condizionale-presente, etc.)

**Why**:
- **Eliminates ambiguity**: Current "presente" appears in 4 different moods, requiring complex mood-tense combination validation
- **Simplifies constraints**: Single enum validation vs complex conditional checks
- **Improves query clarity**: `metadata->>'tense' = 'congiuntivo-presente'` is unambiguous
- **Database consistency**: Fixes `passato-progressivo` vs `imperfetto-progressivo` naming inconsistency

**EPIC 002 Alignment**: All 27 forms match documented system specification exactly
**Alternative Considered**: Keep ambiguous names + mood-tense combination constraints
**Rejected Because**: Complex validation logic prone to errors and harder to maintain

### **Decision 4: Comprehensive Adverb Type System**

**What**: Expand from 4 documented types (manner, time, place, quantity) to 8 types including frequency, affirmation, doubt, interrogative

**Why**:
- **Functional distinction**: Interrogative adverbs (come, quando, dove) have different syntactic behavior
- **Semantic search**: Frequency and affirmation adverbs affect meaning-based filtering
- **Future-proofing**: Comprehensive categorization prevents future schema changes
- **Linguistic accuracy**: Captures full range of Italian adverb semantics

**Data Analysis Insight**: Only 1 adverb ("bene" as type-manner) in current database, confirming low impact of expansion

### **Decision 5: Conditional Database Constraints Strategy**

**What**: Enum validation at database level + conditional logic (gender only for nouns) in constraints

**Why**:
- **Data integrity**: Database prevents invalid enum values from entering system
- **Flexibility**: Application handles complex conditional rules that database constraints can't express elegantly
- **Performance**: Database validation faster than application-level checks
- **Maintainability**: Enum changes require single constraint update vs scattered code changes

**Implementation**: `CHECK ((word_type != 'noun') OR (gender IN (...)))` pattern for conditional fields

### **Decision 6: form_translations Minimal Metadata**

**What**: Only `assignment_method` and `source` fields, avoiding complex tracking

**Why**:
- **YAGNI Principle**: Avoid over-engineering features not immediately needed
- **Scope Focus**: Keep this story focused on core architecture, add complexity later if required
- **Simplicity**: Reduces implementation risk and testing surface area
- **Extensibility**: jsonb structure allows adding fields without schema migration

**Alternative Considered**: Confidence scoring, context specificity, usage frequency
**Rejected Because**: No immediate functional need identified

### **Decision 7: Pre-Implementation Documentation Update (Phase 0)**

**What**: Rewrite EPIC 002 and create Tagging v2 documentation BEFORE any code changes

**Why**:
- **Single Source of Truth**: New architecture makes current EPIC 002 obsolete
- **Coordination**: Story 002.003.2 must align with new schema from the start
- **Developer Experience**: Future development guided by accurate documentation
- **Risk Mitigation**: Prevents architectural misalignment across dependent stories

**Critical**: All future EPICs must reference updated documentation, not obsolete version

### **Decision 8: Dual Schema Transition Strategy**

**What**: Maintain both old and new columns during transition period, use feature flags for gradual adoption

**Why**:
- **Zero Downtime**: System continues operating during migration
- **Risk Mitigation**: Instant rollback capability without data loss
- **Validation Period**: Time to verify new schema works correctly
- **Dependency Management**: Dictionary/conjugation views can migrate independently

**Timeline**: No fixed timeline - driven by completion of dependent EPICs

### **Decision 9: Database-First Migration Approach**

**What**: Migrate data first, then update application code to use new schema

**Why**:
- **Data Safety**: Schema and data changes happen in controlled sequence
- **Validation**: Can verify data migration success before touching application logic
- **Rollback Clarity**: Each phase has clear rollback procedures
- **Testing**: Can test new schema with existing application code before migration

**Alternative Considered**: Application-first migration
**Rejected Because**: Higher risk of data corruption and harder rollback procedures

### **Decision 10: Comprehensive Database Constraints**

**What**: All 27 tenses, conditional word-type validation, standardized enums

**Why**:
- **Data Quality**: Invalid data prevented at database level
- **Developer Feedback**: Constraint violations immediately flag data quality issues
- **System Reliability**: Migration tools can't create invalid combinations
- **Maintenance**: Enum updates centralized in database constraints

**Strictness Rationale**: Better to be strict initially and relax if needed than allow invalid data

### **Decision 11: Performance Equivalence Requirement**

**What**: jsonb queries must perform comparably to existing array operations

**Why**:
- **User Experience**: No degradation in application responsiveness
- **Scalability**: New architecture must handle current data volumes efficiently
- **Index Strategy**: Proper jsonb indexing ensures query performance
- **Benchmark Validation**: Measurable performance criteria for success

**Implementation**: GIN indexes on frequently queried jsonb paths

### **Decision 12: word_translations Schema Simplification**

**What**: Reduce translation metadata to functionality-affecting fields only (register, gender_usage, auxiliary, transitivity)

**Why**:
- **Clear Boundaries**: Separate functional from descriptive metadata
- **System Complexity**: Fewer mandatory fields reduce validation complexity
- **Maintenance**: Simpler schema easier to maintain and extend
- **Optionality**: Descriptive metadata moves to optional_tags array

**Semantic_type & usage**: Determined to be descriptive rather than functional based on system behavior analysis

---

## Technical Implementation Plan

### **PHASE 0: Pre-Implementation Documentation Update**

**CRITICAL FIRST STEP**: Before any schema changes, update foundational documentation:

1. **Rewrite EPIC 002 Complete Architectural Rebuild** to reflect new unified metadata approach
2. **Create Tagging and Database Design v2** documenting new architecture  
3. **Update Story 002.003.2** to align with new schema structure
4. **Review all dependent stories** for architectural consistency

**Rationale**: New unified metadata architecture makes current EPIC 002 and tagging documentation obsolete. All future development must align with updated documentation.

### **PHASE 1: Schema Extension (Week 1)**

#### **1.1 Add New Columns (Non-Breaking Changes)**
```sql
-- Add unified schema columns to all 4 core tables
ALTER TABLE dictionary ADD COLUMN metadata jsonb DEFAULT '{}';
ALTER TABLE dictionary ADD COLUMN optional_tags text[] DEFAULT '{}';

ALTER TABLE word_forms ADD COLUMN metadata jsonb DEFAULT '{}';
ALTER TABLE word_forms ADD COLUMN optional_tags text[] DEFAULT '{}';

-- word_translations: rename existing context_metadata to metadata
ALTER TABLE word_translations RENAME COLUMN context_metadata TO metadata;
ALTER TABLE word_translations ADD COLUMN optional_tags text[] DEFAULT '{}';

-- form_translations: minimal metadata approach
ALTER TABLE form_translations ADD COLUMN metadata jsonb DEFAULT '{}';
ALTER TABLE form_translations ADD COLUMN optional_tags text[] DEFAULT '{}';
```

#### **1.2 Create Backup Infrastructure**
```sql
-- Create backup tables with complete data preservation
CREATE TABLE dictionary_backup_20250822 AS SELECT * FROM dictionary;
CREATE TABLE word_forms_backup_20250822 AS SELECT * FROM word_forms;
CREATE TABLE word_translations_backup_20250822 AS SELECT * FROM word_translations;
CREATE TABLE form_translations_backup_20250822 AS SELECT * FROM form_translations;
```

### **PHASE 2: Data Population (Week 2)**

#### **2.1 Dictionary Metadata Migration**

**Complete Mandatory Metadata Structure**:
```json
{
  // Universal fields (all word types)
  "word_type": "noun|verb|adjective|adverb",
  "cefr_level": "A1|A2|B1|B2|C1|C2|native|academic|literary|specialized",
  "frequency_tier": "top100|top500|top1000|top5000", // only when available
  "irregular": true/false,
  
  // Noun-specific fields
  "gender": "masculine|feminine|common-gender", // nouns only
  
  // Verb-specific fields  
  "conjugation_type": "are|ere|ire|ire-isc", // verbs only
  "auxiliary": "avere|essere|both", // verbs only
  "transitivity": "transitive|intransitive|both", // verbs only
  "reflexive": true/false, // verbs only
  
  // Adjective-specific fields
  "form_pattern": "form-4|form-2|irregular", // adjectives only
  "gradable": true/false, // adjectives only
  
  // Adverb-specific fields
  "adverb_type": "manner|time|place|quantity|frequency|affirmation|doubt|interrogative" // adverbs only
}
```

#### **2.2 Word Forms Metadata Migration - 27 Unique Tense System**

**27 Unique Tense Values** (data-validated):
```sql
-- INDICATIVO (11 tenses)
"presente", "imperfetto", "passato-remoto", "futuro-semplice", "passato-prossimo", 
"trapassato-prossimo", "futuro-anteriore", "trapassato-remoto", 
"presente-progressivo", "imperfetto-progressivo", "futuro-progressivo"

-- CONGIUNTIVO (5 tenses)  
"congiuntivo-presente", "congiuntivo-imperfetto", "congiuntivo-passato", 
"congiuntivo-trapassato", "congiuntivo-presente-progressivo"

-- CONDIZIONALE (3 tenses)
"condizionale-presente", "condizionale-passato", "condizionale-presente-progressivo"

-- IMPERATIVO (2 tenses)
"imperativo-presente", "imperativo-passato"

-- INFINITO (2 tenses)
"infinito-presente", "infinito-passato"

-- PARTICIPIO (2 tenses)
"participio-presente", "participio-passato"

-- GERUNDIO (2 tenses)
"gerundio-presente", "gerundio-passato"
```

**Critical Tense Renaming** (database inconsistency fix):
```sql
-- Fix passato-progressivo → imperfetto-progressivo alignment
UPDATE word_forms 
SET tags = array_replace(tags, 'passato-progressivo', 'imperfetto-progressivo')
WHERE 'passato-progressivo' = ANY(tags);
```

#### **2.3 Translation Metadata Migration**

**Simplified Translation Metadata** (mandatory only):
```json
{
  // Core functionality fields
  "register": "formal|informal|neutral",
  "gender_usage": "male-only|female-only|both|neutral",
  "auxiliary": "avere|essere", // verbs only
  "transitivity": "transitive|intransitive", // verbs only
  
  // Usage constraints (affects form filtering)
  "plurality": "singular-only|plural-only|any", // for reciprocal verbs
  "usage": "direct-reflexive|reciprocal|intransitive" // semantic behavior
}
```

### **PHASE 3: Database Constraints & Validation (Week 3)**

#### **3.1 Comprehensive Database Constraints**

```sql
-- Dictionary constraints
ALTER TABLE dictionary ADD CONSTRAINT chk_dict_meta_word_type
  CHECK (metadata->>'word_type' IN ('noun', 'verb', 'adjective', 'adverb'));

-- Conditional constraints for word-type specific fields
ALTER TABLE dictionary ADD CONSTRAINT chk_dict_meta_gender_nouns_only
  CHECK ((metadata->>'word_type' != 'noun') OR (metadata->>'gender' IN ('masculine', 'feminine', 'common-gender')));

-- Word Forms constraints - All 27 unique tenses
ALTER TABLE word_forms ADD CONSTRAINT chk_forms_meta_tense_27_system
  CHECK (metadata->>'tense' IN (
    'presente', 'imperfetto', 'passato-remoto', 'futuro-semplice', 'passato-prossimo', 'trapassato-prossimo', 'futuro-anteriore', 'trapassato-remoto', 'presente-progressivo', 'imperfetto-progressivo', 'futuro-progressivo',
    'congiuntivo-presente', 'congiuntivo-imperfetto', 'congiuntivo-passato', 'congiuntivo-trapassato', 'congiuntivo-presente-progressivo',
    'condizionale-presente', 'condizionale-passato', 'condizionale-presente-progressivo',
    'imperativo-presente', 'imperativo-passato',
    'infinito-presente', 'infinito-passato',
    'participio-presente', 'participio-passato',
    'gerundio-presente', 'gerundio-passato'
  ));
```

### **PHASE 4: System Integration (Week 4)**

#### **4.1 Migration Tools Update**

**Update SimpleMigrationTest.tsx** to use new metadata structure:
```typescript
// Replace tag array searches with metadata queries
const loadAvailableMetadata = async () => {
  // OLD: Check tags arrays
  const formTags = form.tags || [];
  
  // NEW: Check metadata structure  
  const formMetadata = form.metadata || {};
  const tense = formMetadata.tense;
  const mood = formMetadata.mood;
  
  // Use standardized enum values for filtering
  if (mood === 'congiuntivo' && tense?.startsWith('congiuntivo-')) {
    // Handle subjunctive forms...
  }
};
```

### **PHASE 5: Rollback Procedures & Risk Mitigation**

#### **5.1 Immediate Rollback (Phases 1-3)**
```sql
-- Remove new columns, restore original state
ALTER TABLE dictionary DROP COLUMN metadata, DROP COLUMN optional_tags;
ALTER TABLE word_forms DROP COLUMN metadata, DROP COLUMN optional_tags;
ALTER TABLE word_translations RENAME COLUMN metadata TO context_metadata;
ALTER TABLE word_translations DROP COLUMN optional_tags;
ALTER TABLE form_translations DROP COLUMN metadata, DROP COLUMN optional_tags;
```

### **PHASE 6: Validation & Performance Testing**

#### **6.1 Data Integrity Validation**
```sql
-- Verify migration completeness
SELECT COUNT(*) FROM dictionary WHERE metadata IS NULL OR metadata = '{}';
SELECT COUNT(*) FROM word_forms WHERE metadata IS NULL OR metadata = '{}';

-- Check for any constraint violations
SELECT * FROM dictionary WHERE metadata->>'word_type' = 'noun' AND NOT (metadata ? 'gender');
```

#### **6.2 Performance Benchmarking**
```sql
-- jsonb query performance vs array operations
EXPLAIN ANALYZE SELECT * FROM dictionary WHERE metadata->>'cefr_level' = 'A1';
EXPLAIN ANALYZE SELECT * FROM dictionary WHERE tags && ARRAY['CEFR-A1'];

-- Index recommendations
CREATE INDEX idx_dictionary_metadata_cefr ON dictionary USING gin ((metadata->>'cefr_level'));
CREATE INDEX idx_word_forms_metadata_tense ON word_forms USING gin ((metadata->>'tense'));
```

---

## Migration Strategy

### Current Tag Categorization:
**Mandatory (→ jsonb metadata):**
- Gender, conjugation type, auxiliary selection
- Mood, tense, person, number properties
- Irregularity flags, morphological patterns
- Core usage and register information

**Optional (→ array tags):**
- Frequency rankings (`freq-top100`, `freq-top500`)
- CEFR levels (`CEFR-A1`, `CEFR-A2`)  
- Topic categories (`topic-daily-life`, `business`)
- Regional markers (`regional-tuscany`)
- Style markers (`archaic`, `poetic`, `colloquial`)

### Backwards Compatibility:
- **Keep existing columns** during transition period
- **Populate both formats** until full system migration
- **Feature flags** to enable new schema gradually
- **Monitoring** to catch any integration issues

---

## Definition of Done

- [ ] All 4 core tables have consistent `metadata jsonb` + `optional_tags text[]` columns
- [ ] Existing data successfully migrated with 100% preservation
- [ ] Migration tools work seamlessly with new schema structure  
- [ ] Step 2 metadata loading works consistently across all table types
- [ ] Performance benchmarks show no degradation from schema change
- [ ] Full rollback capability tested and verified
- [ ] Documentation updated to reflect new architecture
- [ ] Code review completed and approved by senior developer

**Success Metrics:**
- Zero data loss during migration
- Migration tool Step 2 functionality works 100% reliably
- Query performance maintained or improved
- Developer experience simplified through consistent schema
- System maintainability significantly improved

---

## Risk Mitigation

**Data Loss Risk**: Comprehensive backup and validation procedures  
**Performance Risk**: Benchmark testing and index optimization  
**Integration Risk**: Gradual rollout with feature flags and monitoring  
**Complexity Risk**: Clear documentation and training for development team

**Dependencies**: Must coordinate with Story 002.003.2 (Migration Tool Rebuild) for optimal integration.